["^ ","~:resource-id",["~:shadow.build.classpath/resource","com/cognitect/transit/types.js"],"~:js","goog.provide(\"com.cognitect.transit.types\");\ngoog.require(\"com.cognitect.transit.util\");\ngoog.require(\"com.cognitect.transit.eq\");\ngoog.require(\"goog.math.Long\");\ngoog.scope(function() {\n  var types = com.cognitect.transit.types, util = com.cognitect.transit.util, eq = com.cognitect.transit.eq, Long = goog.math.Long;\n  if (typeof Symbol != \"undefined\") {\n    types.ITERATOR = Symbol.iterator;\n  } else {\n    types.ITERATOR = \"@@iterator\";\n  }\n  types.TaggedValue = function Transit$TaggedValue(tag, rep) {\n    this.tag = tag;\n    this.rep = rep;\n    this.hashCode = -1;\n  };\n  types.TaggedValue.prototype.toString = function() {\n    return \"[TaggedValue: \" + this.tag + \", \" + this.rep + \"]\";\n  };\n  types.TaggedValue.prototype.equiv = function(other) {\n    return eq.equals(this, other);\n  };\n  types.TaggedValue.prototype[\"equiv\"] = types.TaggedValue.prototype.equiv;\n  types.TaggedValue.prototype.com$cognitect$transit$equals = function(other) {\n    if (other instanceof types.TaggedValue) {\n      return this.tag === other.tag && eq.equals(this.rep, other.rep);\n    } else {\n      return false;\n    }\n  };\n  types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.hashCode === -1) {\n      this.hashCode = eq.hashCombine(eq.hashCode(this.tag), eq.hashCode(this.rep));\n    }\n    return this.hashCode;\n  };\n  types.taggedValue = function(tag, rep) {\n    return new types.TaggedValue(tag, rep);\n  };\n  types.isTaggedValue = function(x) {\n    return x instanceof types.TaggedValue;\n  };\n  types.nullValue = function() {\n    return null;\n  };\n  types.boolValue = function(s) {\n    return s === \"t\";\n  };\n  types.MAX_INT = Long.fromString(\"9007199254740991\");\n  types.MIN_INT = Long.fromString(\"-9007199254740991\");\n  types.intValue = function(s) {\n    if (typeof s === \"number\") {\n      return s;\n    } else if (s instanceof Long) {\n      return s;\n    } else {\n      var n = Long.fromString(s, 10);\n      if (n.greaterThan(types.MAX_INT) || n.lessThan(types.MIN_INT)) {\n        return n;\n      } else {\n        return n.toNumber();\n      }\n    }\n  };\n  Long.prototype.equiv = function(other) {\n    return eq.equals(this, other);\n  };\n  Long.prototype[\"equiv\"] = Long.prototype.equiv;\n  Long.prototype.com$cognitect$transit$equals = function(other) {\n    return other instanceof Long && this.equals(other);\n  };\n  Long.prototype.com$cognitect$transit$hashCode = function() {\n    return this.toInt();\n  };\n  types.isInteger = function(x) {\n    if (x instanceof Long) {\n      return true;\n    } else {\n      return typeof x === \"number\" && !isNaN(x) && !(x === Infinity) && parseFloat(x) === parseInt(x, 10);\n    }\n  };\n  types.floatValue = function(s) {\n    return parseFloat(s);\n  };\n  types.bigInteger = function(s) {\n    return types.taggedValue(\"n\", s);\n  };\n  types.isBigInteger = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"n\";\n  };\n  types.bigDecimalValue = function(s) {\n    return types.taggedValue(\"f\", s);\n  };\n  types.isBigDecimal = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"f\";\n  };\n  types.charValue = function(s) {\n    return s;\n  };\n  types.Keyword = function Transit$Keyword(name) {\n    this._name = name;\n    this.hashCode = -1;\n  };\n  types.Keyword.prototype.toString = function() {\n    return \":\" + this._name;\n  };\n  types.Keyword.prototype[\"namespace\"] = function() {\n    var idx = this._name.indexOf(\"/\");\n    if (idx != -1) {\n      return this._name.substring(0, idx);\n    } else {\n      return null;\n    }\n  };\n  types.Keyword.prototype[\"name\"] = function() {\n    var idx = this._name.indexOf(\"/\");\n    if (idx != -1) {\n      return this._name.substring(idx + 1, this._name.length);\n    } else {\n      return this._name;\n    }\n  };\n  types.Keyword.prototype.equiv = function(other) {\n    return eq.equals(this, other);\n  };\n  types.Keyword.prototype[\"equiv\"] = types.Keyword.prototype.equiv;\n  types.Keyword.prototype.com$cognitect$transit$equals = function(other) {\n    return other instanceof types.Keyword && this._name == other._name;\n  };\n  types.Keyword.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.hashCode === -1) {\n      this.hashCode = eq.hashCode(this._name);\n    }\n    return this.hashCode;\n  };\n  types.keyword = function(s) {\n    return new types.Keyword(s);\n  };\n  types.isKeyword = function(x) {\n    return x instanceof types.Keyword;\n  };\n  types.Symbol = function Transit$Symbol(name) {\n    this._name = name;\n    this.hashCode = -1;\n  };\n  types.Symbol.prototype[\"namespace\"] = function() {\n    var idx = this._name.indexOf(\"/\");\n    if (idx != -1) {\n      return this._name.substring(0, idx);\n    } else {\n      return null;\n    }\n  };\n  types.Symbol.prototype[\"name\"] = function() {\n    var idx = this._name.indexOf(\"/\");\n    if (idx != -1) {\n      return this._name.substring(idx + 1, this._name.length);\n    } else {\n      return this._name;\n    }\n  };\n  types.Symbol.prototype.toString = function() {\n    return this._name;\n  };\n  types.Symbol.prototype.equiv = function(other) {\n    return eq.equals(this, other);\n  };\n  types.Symbol.prototype[\"equiv\"] = types.Symbol.prototype.equiv;\n  types.Symbol.prototype.com$cognitect$transit$equals = function(other) {\n    return other instanceof types.Symbol && this._name == other._name;\n  };\n  types.Symbol.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.hashCode === -1) {\n      this.hashCode = eq.hashCode(this._name);\n    }\n    return this.hashCode;\n  };\n  types.symbol = function(s) {\n    return new types.Symbol(s);\n  };\n  types.isSymbol = function(x) {\n    return x instanceof types.Symbol;\n  };\n  types.hexFor = function(aLong, sidx, eidx) {\n    var ret = \"\";\n    eidx = eidx || sidx + 1;\n    for (var i = sidx, shift = (7 - i) * 8, mask = Long.fromInt(255).shiftLeft(shift); i < eidx; i++, shift -= 8, mask = mask.shiftRightUnsigned(8)) {\n      var s = aLong.and(mask).shiftRightUnsigned(shift).toString(16);\n      if (s.length == 1) {\n        s = \"0\" + s;\n      }\n      ret += s;\n    }\n    return ret;\n  };\n  types.UUID = function Transit$UUID(high, low) {\n    this.high = high;\n    this.low = low;\n    this.hashCode = -1;\n  };\n  types.UUID.prototype.getLeastSignificantBits = function() {\n    return this.low;\n  };\n  types.UUID.prototype.getMostSignificantBits = function() {\n    return this.high;\n  };\n  types.UUID.prototype.toString = function() {\n    var s = \"\", hi64 = this.high, lo64 = this.low;\n    s += types.hexFor(hi64, 0, 4) + \"-\";\n    s += types.hexFor(hi64, 4, 6) + \"-\";\n    s += types.hexFor(hi64, 6, 8) + \"-\";\n    s += types.hexFor(lo64, 0, 2) + \"-\";\n    s += types.hexFor(lo64, 2, 8);\n    return s;\n  };\n  types.UUID.prototype.equiv = function(other) {\n    return eq.equals(this, other);\n  };\n  types.UUID.prototype[\"equiv\"] = types.UUID.prototype.equiv;\n  types.UUID.prototype.com$cognitect$transit$equals = function(other) {\n    return other instanceof types.UUID && this.high.equals(other.high) && this.low.equals(other.low);\n  };\n  types.UUID.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.hashCode === -1) {\n      this.hashCode = eq.hashCode(this.toString());\n    }\n    return this.hashCode;\n  };\n  types.UUIDfromString = function uuidFromString(s) {\n    s = s.replace(/-/g, \"\");\n    var hi64 = null, lo64 = null, hi32 = 0, lo32 = 0, off = 24, i = 0;\n    for (hi32 = 0, i = 0, off = 24; i < 8; i += 2, off -= 8) {\n      hi32 |= parseInt(s.substring(i, i + 2), 16) << off;\n    }\n    for (lo32 = 0, i = 8, off = 24; i < 16; i += 2, off -= 8) {\n      lo32 |= parseInt(s.substring(i, i + 2), 16) << off;\n    }\n    hi64 = Long.fromBits(lo32, hi32);\n    for (hi32 = 0, i = 16, off = 24; i < 24; i += 2, off -= 8) {\n      hi32 |= parseInt(s.substring(i, i + 2), 16) << off;\n    }\n    for (lo32 = 0, i = 24, off = 24; i < 32; i += 2, off -= 8) {\n      lo32 |= parseInt(s.substring(i, i + 2), 16) << off;\n    }\n    lo64 = Long.fromBits(lo32, hi32);\n    return new types.UUID(hi64, lo64);\n  };\n  types.uuid = function(s) {\n    return types.UUIDfromString(s);\n  };\n  types.isUUID = function(x) {\n    return x instanceof types.UUID;\n  };\n  types.date = function(s) {\n    s = typeof s === \"number\" ? s : parseInt(s, 10);\n    return new Date(s);\n  };\n  types.verboseDate = function(s) {\n    return new Date(s);\n  };\n  Date.prototype.com$cognitect$transit$equals = function(other) {\n    if (other instanceof Date) {\n      return this.valueOf() === other.valueOf();\n    } else {\n      return false;\n    }\n  };\n  Date.prototype.com$cognitect$transit$hashCode = function() {\n    return this.valueOf();\n  };\n  types.binary = function(str, decoder) {\n    if ((!decoder || decoder.preferBuffers !== false) && typeof goog.global.Buffer != \"undefined\") {\n      return new goog.global.Buffer(str, \"base64\");\n    } else if (typeof Uint8Array != \"undefined\") {\n      return util.Base64ToUint8(str);\n    } else {\n      return types.taggedValue(\"b\", str);\n    }\n  };\n  types.isBinary = function(x) {\n    if (typeof goog.global.Buffer != \"undefined\" && x instanceof goog.global.Buffer) {\n      return true;\n    } else if (typeof Uint8Array != \"undefined\" && x instanceof Uint8Array) {\n      return true;\n    } else {\n      return x instanceof types.TaggedValue && x.tag === \"b\";\n    }\n  };\n  types.uri = function(s) {\n    return types.taggedValue(\"r\", s);\n  };\n  types.isURI = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"r\";\n  };\n  types.KEYS = 0;\n  types.VALUES = 1;\n  types.ENTRIES = 2;\n  types.TransitArrayMapIterator = function Transit$ArrayMapIterator(entries, type) {\n    this.entries = entries;\n    this.type = type || types.KEYS;\n    this.idx = 0;\n  };\n  types.TransitArrayMapIterator.prototype.next = function() {\n    if (this.idx < this.entries.length) {\n      var value = null;\n      if (this.type === types.KEYS) {\n        value = this.entries[this.idx];\n      } else if (this.type === types.VALUES) {\n        value = this.entries[this.idx + 1];\n      } else {\n        value = [this.entries[this.idx], this.entries[this.idx + 1]];\n      }\n      var ret = {\"value\":value, \"done\":false};\n      this.idx += 2;\n      return ret;\n    } else {\n      return {\"value\":null, \"done\":true};\n    }\n  };\n  types.TransitArrayMapIterator.prototype[\"next\"] = types.TransitArrayMapIterator.prototype.next;\n  types.TransitArrayMapIterator.prototype[types.ITERATOR] = function() {\n    return this;\n  };\n  types.TransitMapIterator = function Transit$MapIterator(map, type) {\n    this.map = map;\n    this.type = type || types.KEYS;\n    this.keys = this.map.getKeys();\n    this.idx = 0;\n    this.bucket = null;\n    this.bucketIdx = 0;\n  };\n  types.TransitMapIterator.prototype.next = function() {\n    if (this.idx < this.map.size) {\n      if (this.bucket == null || !(this.bucketIdx < this.bucket.length)) {\n        this.bucket = this.map.map[this.keys[this.idx]];\n        this.bucketIdx = 0;\n      }\n      var value = null;\n      if (this.type === types.KEYS) {\n        value = this.bucket[this.bucketIdx];\n      } else if (this.type === types.VALUES) {\n        value = this.bucket[this.bucketIdx + 1];\n      } else {\n        value = [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]];\n      }\n      var ret = {\"value\":value, \"done\":false};\n      this.idx++;\n      this.bucketIdx += 2;\n      return ret;\n    } else {\n      return {\"value\":null, \"done\":true};\n    }\n  };\n  types.TransitMapIterator.prototype[\"next\"] = types.TransitMapIterator.prototype.next;\n  types.TransitMapIterator.prototype[types.ITERATOR] = function() {\n    return this;\n  };\n  types.mapEquals = function(me, you) {\n    if (me instanceof types.TransitMap && types.isMap(you)) {\n      if (me.size !== you.size) {\n        return false;\n      }\n      for (var code in me.map) {\n        var bucket = me.map[code];\n        for (var j = 0; j < bucket.length; j += 2) {\n          if (!eq.equals(bucket[j + 1], you.get(bucket[j]))) {\n            return false;\n          }\n        }\n      }\n      return true;\n    } else if (me instanceof types.TransitArrayMap && types.isMap(you)) {\n      if (me.size !== you.size) {\n        return false;\n      }\n      var entries = me._entries;\n      for (var j = 0; j < entries.length; j += 2) {\n        if (!eq.equals(entries[j + 1], you.get(entries[j]))) {\n          return false;\n        }\n      }\n      return true;\n    } else if (you != null && typeof you === \"object\") {\n      var ks = util.objectKeys(you), kslen = ks.length;\n      if (me.size === kslen) {\n        for (var i = 0; i < kslen; i++) {\n          var k = ks[i];\n          if (!me.has(k) || !eq.equals(you[k], me.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n  types.SMALL_ARRAY_MAP_THRESHOLD = 8;\n  types.ARRAY_MAP_THRESHOLD = 32;\n  types.ARRAY_MAP_ACCESS_THRESHOLD = 32;\n  types.print = function(x) {\n    if (x == null) {\n      return \"null\";\n    }\n    if (goog.typeOf(x) === \"array\") {\n      return \"[\" + x.toString() + \"]\";\n    } else if (goog.typeOf(x) === \"string\") {\n      return '\"' + x + '\"';\n    } else {\n      return x.toString();\n    }\n  };\n  types.printMap = function(map) {\n    var idx = 0, str = \"TransitMap {\";\n    map.forEach(function(v, k) {\n      str += types.print(k) + \" \\x3d\\x3e \" + types.print(v);\n      if (idx < map.size - 1) {\n        str += \", \";\n      }\n      idx++;\n    });\n    return str + \"}\";\n  };\n  types.printSet = function(set) {\n    var idx = 0, str = \"TransitSet {\";\n    set.forEach(function(v) {\n      str += types.print(v);\n      if (idx < set.size - 1) {\n        str += \", \";\n      }\n      idx++;\n    });\n    return str + \"}\";\n  };\n  types.TransitArrayMap = function Transit$ArrayMap(entries) {\n    this._entries = entries;\n    this.backingMap = null;\n    this.hashCode = -1;\n    this.size = entries.length / 2;\n    this.accesses = 0;\n  };\n  types.TransitArrayMap.prototype.toString = function() {\n    return types.printMap(this);\n  };\n  types.TransitArrayMap.prototype[\"inspect\"] = function() {\n    return this.toString();\n  };\n  types.TransitArrayMap.prototype.convert = function() {\n    if (this.backingMap) {\n      throw Error(\"Invalid operation, already converted\");\n    }\n    if (this.size < types.SMALL_ARRAY_MAP_THRESHOLD) {\n      return false;\n    }\n    this.accesses++;\n    if (this.accesses > types.ARRAY_MAP_ACCESS_THRESHOLD) {\n      this.backingMap = types.map(this._entries, false, true);\n      this._entries = [];\n      return true;\n    } else {\n      return false;\n    }\n  };\n  types.TransitArrayMap.prototype.clear = function() {\n    this.hashCode = -1;\n    if (this.backingMap) {\n      this.backingMap.clear();\n      this.size = 0;\n    } else {\n      this._entries = [];\n      this.size = 0;\n    }\n  };\n  types.TransitArrayMap.prototype[\"clear\"] = types.TransitArrayMap.prototype.clear;\n  types.TransitArrayMap.prototype.keys = function() {\n    if (this.backingMap) {\n      return this.backingMap.keys();\n    } else {\n      return new types.TransitArrayMapIterator(this._entries, types.KEYS);\n    }\n  };\n  types.TransitArrayMap.prototype[\"keys\"] = types.TransitArrayMap.prototype.keys;\n  types.TransitArrayMap.prototype.keySet = function() {\n    if (this.backingMap) {\n      return this.backingMap.keySet();\n    } else {\n      var ret = [];\n      for (var i = 0, j = 0; j < this._entries.length; i++, j += 2) {\n        ret[i] = this._entries[j];\n      }\n      return ret;\n    }\n  };\n  types.TransitArrayMap.prototype[\"keySet\"] = types.TransitArrayMap.prototype.keySet;\n  types.TransitArrayMap.prototype.entries = function() {\n    if (this.backingMap) {\n      return this.backingMap.entries();\n    } else {\n      return new types.TransitArrayMapIterator(this._entries, types.ENTRIES);\n    }\n  };\n  types.TransitArrayMap.prototype[\"entries\"] = types.TransitArrayMap.prototype.entries;\n  types.TransitArrayMap.prototype.values = function() {\n    if (this.backingMap) {\n      return this.backingMap.values();\n    } else {\n      return new types.TransitArrayMapIterator(this._entries, types.VALUES);\n    }\n  };\n  types.TransitArrayMap.prototype[\"values\"] = types.TransitArrayMap.prototype.values;\n  types.TransitArrayMap.prototype.forEach = function(f) {\n    if (this.backingMap) {\n      this.backingMap.forEach(f);\n    } else {\n      for (var i = 0; i < this._entries.length; i += 2) {\n        f(this._entries[i + 1], this._entries[i]);\n      }\n    }\n  };\n  types.TransitArrayMap.prototype[\"forEach\"] = types.TransitArrayMap.prototype.forEach;\n  types.TransitArrayMap.prototype.get = function(k, notFound) {\n    if (this.backingMap) {\n      return this.backingMap.get(k);\n    } else {\n      if (this.convert()) {\n        return this.get(k);\n      } else {\n        for (var i = 0; i < this._entries.length; i += 2) {\n          if (eq.equals(this._entries[i], k)) {\n            return this._entries[i + 1];\n          }\n        }\n        return notFound;\n      }\n    }\n  };\n  types.TransitArrayMap.prototype[\"get\"] = types.TransitArrayMap.prototype.get;\n  types.TransitArrayMap.prototype.has = function(k) {\n    if (this.backingMap) {\n      return this.backingMap.has(k);\n    } else {\n      if (this.convert()) {\n        return this.has(k);\n      } else {\n        for (var i = 0; i < this._entries.length; i += 2) {\n          if (eq.equals(this._entries[i], k)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n  };\n  types.TransitArrayMap.prototype[\"has\"] = types.TransitArrayMap.prototype.has;\n  types.TransitArrayMap.prototype.set = function(k, v) {\n    this.hashCode = -1;\n    if (this.backingMap) {\n      this.backingMap.set(k, v);\n      this.size = this.backingMap.size;\n    } else {\n      for (var i = 0; i < this._entries.length; i += 2) {\n        if (eq.equals(this._entries[i], k)) {\n          this._entries[i + 1] = v;\n          return;\n        }\n      }\n      this._entries.push(k);\n      this._entries.push(v);\n      this.size++;\n      if (this.size > types.ARRAY_MAP_THRESHOLD) {\n        this.backingMap = types.map(this._entries, false, true);\n        this._entries = null;\n      }\n    }\n  };\n  types.TransitArrayMap.prototype[\"set\"] = types.TransitArrayMap.prototype.set;\n  types.TransitArrayMap.prototype[\"delete\"] = function(k) {\n    this.hashCode = -1;\n    if (this.backingMap) {\n      var ret = this.backingMap.delete(k);\n      this.size = this.backingMap.size;\n      return ret;\n    } else {\n      for (var i = 0; i < this._entries.length; i += 2) {\n        if (eq.equals(this._entries[i], k)) {\n          var ret = this._entries[i + 1];\n          this._entries.splice(i, 2);\n          this.size--;\n          return ret;\n        }\n      }\n    }\n  };\n  types.TransitArrayMap.prototype.clone = function() {\n    var clone = types.map();\n    this.forEach(function(v, k) {\n      clone.set(k, v);\n    });\n    return clone;\n  };\n  types.TransitArrayMap.prototype[\"clone\"] = types.TransitArrayMap.prototype.clone;\n  types.TransitArrayMap.prototype[types.ITERATOR] = function() {\n    return this.entries();\n  };\n  types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.backingMap) {\n      return this.backingMap.com$cognitect$transit$hashCode();\n    } else {\n      if (this.hashCode === -1) {\n        this.hashCode = eq.hashMapLike(this);\n      }\n      return this.hashCode;\n    }\n  };\n  types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(other) {\n    if (this.backingMap) {\n      return types.mapEquals(this.backingMap, other);\n    } else {\n      return types.mapEquals(this, other);\n    }\n  };\n  types.TransitMap = function Transit$Map(keys, map, size) {\n    this.map = map || {};\n    this._keys = keys || [];\n    this.size = size || 0;\n    this.hashCode = -1;\n  };\n  types.TransitMap.prototype.toString = function() {\n    return types.printMap(this);\n  };\n  types.TransitMap.prototype[\"inspect\"] = function() {\n    return this.toString();\n  };\n  types.TransitMap.prototype.clear = function() {\n    this.hashCode = -1;\n    this.map = {};\n    this._keys = [];\n    this.size = 0;\n  };\n  types.TransitMap.prototype[\"clear\"] = types.TransitMap.prototype.clear;\n  types.TransitMap.prototype.getKeys = function() {\n    if (this._keys != null) {\n      return this._keys;\n    } else {\n      return util.objectKeys(this.map);\n    }\n  };\n  types.TransitMap.prototype[\"delete\"] = function(k) {\n    this.hashCode = -1;\n    this._keys = null;\n    var code = eq.hashCode(k), bucket = this.map[code];\n    for (var i = 0; i < bucket.length; i += 2) {\n      if (eq.equals(k, bucket[i])) {\n        var ret = bucket[i + 1];\n        bucket.splice(i, 2);\n        if (bucket.length === 0) {\n          delete this.map[code];\n        }\n        this.size--;\n        return ret;\n      }\n    }\n  };\n  types.TransitMap.prototype.entries = function() {\n    return new types.TransitMapIterator(this, types.ENTRIES);\n  };\n  types.TransitMap.prototype[\"entries\"] = types.TransitMap.prototype.entries;\n  types.TransitMap.prototype.forEach = function(callback) {\n    var ks = this.getKeys();\n    for (var i = 0; i < ks.length; i++) {\n      var bucket = this.map[ks[i]];\n      for (var j = 0; j < bucket.length; j += 2) {\n        callback(bucket[j + 1], bucket[j], this);\n      }\n    }\n  };\n  types.TransitMap.prototype[\"forEach\"] = types.TransitMap.prototype.forEach;\n  types.TransitMap.prototype.get = function(k, notFound) {\n    var code = eq.hashCode(k), bucket = this.map[code];\n    if (bucket != null) {\n      for (var i = 0; i < bucket.length; i += 2) {\n        if (eq.equals(k, bucket[i])) {\n          return bucket[i + 1];\n        }\n      }\n    } else {\n      return notFound;\n    }\n  };\n  types.TransitMap.prototype[\"get\"] = types.TransitMap.prototype.get;\n  types.TransitMap.prototype.has = function(k) {\n    var code = eq.hashCode(k), bucket = this.map[code];\n    if (bucket != null) {\n      for (var i = 0; i < bucket.length; i += 2) {\n        if (eq.equals(k, bucket[i])) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      return false;\n    }\n  };\n  types.TransitMap.prototype[\"has\"] = types.TransitMap.prototype.has;\n  types.TransitMap.prototype.keys = function() {\n    return new types.TransitMapIterator(this, types.KEYS);\n  };\n  types.TransitMap.prototype[\"keys\"] = types.TransitMap.prototype.keys;\n  types.TransitMap.prototype.keySet = function() {\n    var keys = this.getKeys(), ret = [];\n    for (var i = 0; i < keys.length; i++) {\n      var bucket = this.map[keys[i]];\n      for (var j = 0; j < bucket.length; j += 2) {\n        ret.push(bucket[j]);\n      }\n    }\n    return ret;\n  };\n  types.TransitMap.prototype[\"keySet\"] = types.TransitMap.prototype.keySet;\n  types.TransitMap.prototype.set = function(k, v) {\n    this.hashCode = -1;\n    var code = eq.hashCode(k), bucket = this.map[code];\n    if (bucket == null) {\n      if (this._keys) {\n        this._keys.push(code);\n      }\n      this.map[code] = [k, v];\n      this.size++;\n    } else {\n      var newEntry = true;\n      for (var i = 0; i < bucket.length; i += 2) {\n        if (eq.equals(v, bucket[i])) {\n          newEntry = false;\n          bucket[i] = v;\n          break;\n        }\n      }\n      if (newEntry) {\n        bucket.push(k);\n        bucket.push(v);\n        this.size++;\n      }\n    }\n  };\n  types.TransitMap.prototype[\"set\"] = types.TransitMap.prototype.set;\n  types.TransitMap.prototype.values = function() {\n    return new types.TransitMapIterator(this, types.VALUES);\n  };\n  types.TransitMap.prototype[\"values\"] = types.TransitMap.prototype.values;\n  types.TransitMap.prototype.clone = function() {\n    var clone = types.map();\n    this.forEach(function(v, k) {\n      clone.set(k, v);\n    });\n    return clone;\n  };\n  types.TransitMap.prototype[\"clone\"] = types.TransitMap.prototype.clone;\n  types.TransitMap.prototype[types.ITERATOR] = function() {\n    return this.entries();\n  };\n  types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {\n    if (this.hashCode === -1) {\n      this.hashCode = eq.hashMapLike(this);\n    }\n    return this.hashCode;\n  };\n  types.TransitMap.prototype.com$cognitect$transit$equals = function(other) {\n    return types.mapEquals(this, other);\n  };\n  types.map = function(arr, checkDups, hashMap) {\n    arr = arr || [];\n    checkDups = checkDups === false ? checkDups : true;\n    hashMap = hashMap === true ? hashMap : false;\n    if (!hashMap && arr.length <= types.ARRAY_MAP_THRESHOLD * 2) {\n      if (checkDups) {\n        var t = arr;\n        arr = [];\n        for (var i = 0; i < t.length; i += 2) {\n          var seen = false;\n          for (var j = 0; j < arr.length; j += 2) {\n            if (eq.equals(arr[j], t[i])) {\n              arr[j + 1] = t[i + 1];\n              seen = true;\n              break;\n            }\n          }\n          if (!seen) {\n            arr.push(t[i]);\n            arr.push(t[i + 1]);\n          }\n        }\n      }\n      return new types.TransitArrayMap(arr);\n    } else {\n      var map = {}, keys = [], size = 0;\n      for (var i = 0; i < arr.length; i += 2) {\n        var code = eq.hashCode(arr[i]), bucket = map[code];\n        if (bucket == null) {\n          keys.push(code);\n          map[code] = [arr[i], arr[i + 1]];\n          size++;\n        } else {\n          var newEntry = true;\n          for (var j = 0; j < bucket.length; j += 2) {\n            if (eq.equals(bucket[j], arr[i])) {\n              bucket[j + 1] = arr[i + 1];\n              newEntry = false;\n              break;\n            }\n          }\n          if (newEntry) {\n            bucket.push(arr[i]);\n            bucket.push(arr[i + 1]);\n            size++;\n          }\n        }\n      }\n      return new types.TransitMap(keys, map, size);\n    }\n  };\n  types.isArrayMap = function(x) {\n    return x instanceof types.TransitArrayMap;\n  };\n  types.isMap = function(x) {\n    return x instanceof types.TransitArrayMap || x instanceof types.TransitMap;\n  };\n  types.TransitSet = function Transit$Set(map) {\n    this.map = map;\n    this.size = map.size;\n  };\n  types.TransitSet.prototype.toString = function() {\n    return types.printSet(this);\n  };\n  types.TransitSet.prototype[\"inspect\"] = function() {\n    return this.toString();\n  };\n  types.TransitSet.prototype.add = function(value) {\n    this.map.set(value, value);\n    this.size = this.map.size;\n  };\n  types.TransitSet.prototype[\"add\"] = types.TransitSet.prototype.add;\n  types.TransitSet.prototype.clear = function() {\n    this.map = new types.TransitMap();\n    this.size = 0;\n  };\n  types.TransitSet.prototype[\"clear\"] = types.TransitSet.prototype.clear;\n  types.TransitSet.prototype[\"delete\"] = function(value) {\n    var ret = this.map.delete(value);\n    this.size = this.map.size;\n    return ret;\n  };\n  types.TransitSet.prototype.entries = function() {\n    return this.map.entries();\n  };\n  types.TransitSet.prototype[\"entries\"] = types.TransitSet.prototype.entries;\n  types.TransitSet.prototype.forEach = function(iterator, thisArg) {\n    var self = this;\n    this.map.forEach(function(v, k, m) {\n      iterator(k, self);\n    });\n  };\n  types.TransitSet.prototype[\"forEach\"] = types.TransitSet.prototype.forEach;\n  types.TransitSet.prototype.has = function(value) {\n    return this.map.has(value);\n  };\n  types.TransitSet.prototype[\"has\"] = types.TransitSet.prototype.has;\n  types.TransitSet.prototype.keys = function() {\n    return this.map.keys();\n  };\n  types.TransitSet.prototype[\"keys\"] = types.TransitSet.prototype.keys;\n  types.TransitSet.prototype.keySet = function() {\n    return this.map.keySet();\n  };\n  types.TransitSet.prototype[\"keySet\"] = types.TransitSet.prototype.keySet;\n  types.TransitSet.prototype.values = function() {\n    return this.map.values();\n  };\n  types.TransitSet.prototype[\"values\"] = types.TransitSet.prototype.values;\n  types.TransitSet.prototype.clone = function() {\n    var clone = types.set();\n    this.forEach(function(k) {\n      clone.add(k);\n    });\n    return clone;\n  };\n  types.TransitSet.prototype[\"clone\"] = types.TransitSet.prototype.clone;\n  types.TransitSet.prototype[types.ITERATOR] = function() {\n    return this.values();\n  };\n  types.TransitSet.prototype.com$cognitect$transit$equals = function(other) {\n    if (other instanceof types.TransitSet) {\n      if (this.size === other.size) {\n        return eq.equals(this.map, other.map);\n      }\n    } else {\n      return false;\n    }\n  };\n  types.TransitSet.prototype.com$cognitect$transit$hashCode = function(other) {\n    return eq.hashCode(this.map);\n  };\n  types.set = function(arr) {\n    arr = arr || [];\n    var map = {}, keys = [], size = 0;\n    for (var i = 0; i < arr.length; i++) {\n      var code = eq.hashCode(arr[i]), vals = map[code];\n      if (vals == null) {\n        keys.push(code);\n        map[code] = [arr[i], arr[i]];\n        size++;\n      } else {\n        var newEntry = true;\n        for (var j = 0; j < vals.length; j += 2) {\n          if (eq.equals(vals[j], arr[i])) {\n            newEntry = false;\n            break;\n          }\n        }\n        if (newEntry) {\n          vals.push(arr[i]);\n          vals.push(arr[i]);\n          size++;\n        }\n      }\n    }\n    return new types.TransitSet(new types.TransitMap(keys, map, size));\n  };\n  types.isSet = function(x) {\n    return x instanceof types.TransitSet;\n  };\n  types.quoted = function(obj) {\n    return types.taggedValue(\"'\", obj);\n  };\n  types.isQuoted = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"'\";\n  };\n  types.list = function(xs) {\n    return types.taggedValue(\"list\", xs);\n  };\n  types.isList = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"list\";\n  };\n  types.link = function(rep) {\n    return types.taggedValue(\"link\", rep);\n  };\n  types.isLink = function(x) {\n    return x instanceof types.TaggedValue && x.tag === \"link\";\n  };\n  types.specialDouble = function(v) {\n    switch(v) {\n      case \"-INF\":\n        return -Infinity;\n      case \"INF\":\n        return Infinity;\n      case \"NaN\":\n        return NaN;\n      default:\n        throw new Error(\"Invalid special double value \" + v);\n        break;\n    }\n  };\n});\n","~:source","// Copyright 2014 Cognitect. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide(\"com.cognitect.transit.types\");\ngoog.require(\"com.cognitect.transit.util\");\ngoog.require(\"com.cognitect.transit.eq\");\ngoog.require(\"goog.math.Long\");\n\ngoog.scope(function() {\n\n    var types = com.cognitect.transit.types,\n        util  = com.cognitect.transit.util,\n        eq    = com.cognitect.transit.eq,\n        Long  = goog.math.Long;\n\n    if(typeof Symbol != \"undefined\") {\n        types.ITERATOR = Symbol.iterator;\n    } else {\n        types.ITERATOR = \"@@iterator\";\n    }\n\n    /**\n     * @constructor\n     */\n    types.TaggedValue = function Transit$TaggedValue(tag, rep) {\n        this.tag = tag;\n        this.rep = rep;\n        this.hashCode = -1;\n    };\n\n    types.TaggedValue.prototype.toString = function() {\n        return \"[TaggedValue: \" + this.tag + \", \" + this.rep + \"]\";\n    };\n\n    types.TaggedValue.prototype.equiv = function(other) {\n        return eq.equals(this, other);\n    };\n    types.TaggedValue.prototype[\"equiv\"] = types.TaggedValue.prototype.equiv;\n\n    types.TaggedValue.prototype.com$cognitect$transit$equals = function(other) {\n        if(other instanceof types.TaggedValue) {\n            return (this.tag === other.tag) && eq.equals(this.rep, other.rep);\n        } else {\n            return false;\n        }\n    };\n\n    types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.hashCode === -1) {\n            this.hashCode = eq.hashCombine(eq.hashCode(this.tag), eq.hashCode(this.rep));\n        }\n        return this.hashCode;\n    };\n\n    types.taggedValue = function(tag, rep) {\n        return new types.TaggedValue(tag, rep);\n    };\n\n    types.isTaggedValue = function(x) {\n        return x instanceof types.TaggedValue;\n    };\n\n    types.nullValue = function() {\n        return null;\n    };\n\n    types.boolValue = function(s) {\n        return s === \"t\";\n    };\n\n    types.MAX_INT = Long.fromString(\"9007199254740991\");\n    types.MIN_INT = Long.fromString(\"-9007199254740991\");\n\n    types.intValue = function(s) {\n        if(typeof s === \"number\") {\n            return s;\n        } else if(s instanceof Long) {\n            return s;\n        } else {\n            var n = Long.fromString(s, 10);\n            if(n.greaterThan(types.MAX_INT) ||\n                n.lessThan(types.MIN_INT)) {\n                return n;\n            } else {\n                return n.toNumber();\n            }\n        }\n    };\n\n    Long.prototype.equiv = function(other) {\n        return eq.equals(this, other);\n    };\n    Long.prototype[\"equiv\"] = Long.prototype.equiv;\n\n    Long.prototype.com$cognitect$transit$equals = function(other) {\n        return (other instanceof Long) && this.equals(other);\n    };\n\n    Long.prototype.com$cognitect$transit$hashCode = function() {\n        return this.toInt();\n    };\n\n    types.isInteger = function(x) {\n        if(x instanceof Long) {\n            return true;\n        } else {\n            return (typeof x === \"number\") && !isNaN(x) && !(x === Infinity) && (parseFloat(x) === parseInt(x, 10));\n        }\n    };\n\n    types.floatValue = function(s) {\n        return parseFloat(s);\n    };\n\n    types.bigInteger = function(s) {\n        return types.taggedValue(\"n\", s);\n    };\n\n    types.isBigInteger = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"n\");\n    };\n\n    types.bigDecimalValue = function(s) {\n        return types.taggedValue(\"f\", s);\n    };\n\n    types.isBigDecimal = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"f\");\n    };\n\n    types.charValue = function(s) {\n        return s;\n    };\n\n    /**\n     * @constructor\n     */\n    types.Keyword = function Transit$Keyword(name) {\n        this._name = name;\n        this.hashCode = -1;\n    };\n\n    types.Keyword.prototype.toString = function() {\n        return \":\"+this._name;\n    };\n\n    types.Keyword.prototype[\"namespace\"] = function() {\n        var idx = this._name.indexOf(\"/\");\n        if(idx != -1) {\n            return this._name.substring(0, idx);\n        } else {\n            return null;\n        }\n    };\n\n    types.Keyword.prototype[\"name\"] = function() {\n        var idx = this._name.indexOf(\"/\");\n        if(idx != -1) {\n            return this._name.substring(idx+1, this._name.length);\n        } else {\n            return this._name;\n        }\n    };\n\n    types.Keyword.prototype.equiv = function(other) {\n        return eq.equals(this, other);\n    };\n    types.Keyword.prototype[\"equiv\"] = types.Keyword.prototype.equiv;\n\n    types.Keyword.prototype.com$cognitect$transit$equals = function(other) {\n        return (other instanceof types.Keyword) && this._name == other._name;\n    };\n\n    types.Keyword.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.hashCode === -1) {\n            this.hashCode = eq.hashCode(this._name);\n        }\n        return this.hashCode;\n    };\n\n    types.keyword = function(s) {\n        return new types.Keyword(s);\n    };\n\n    types.isKeyword = function(x) {\n        return x instanceof types.Keyword;\n    };\n\n    /**\n     * @constructor\n     */\n    types.Symbol = function Transit$Symbol(name) {\n        this._name = name;\n        this.hashCode = -1;\n    };\n\n    types.Symbol.prototype[\"namespace\"] = function() {\n        var idx = this._name.indexOf(\"/\");\n        if(idx != -1) {\n            return this._name.substring(0, idx);\n        } else {\n            return null;\n        }\n    };\n\n    types.Symbol.prototype[\"name\"] = function() {\n        var idx = this._name.indexOf(\"/\");\n        if(idx != -1) {\n            return this._name.substring(idx+1, this._name.length);\n        } else {\n            return this._name;\n        }\n    };\n\n    types.Symbol.prototype.toString = function() {\n        return this._name;\n    };\n\n    types.Symbol.prototype.equiv = function(other) {\n        return eq.equals(this, other);\n    };\n    types.Symbol.prototype[\"equiv\"] = types.Symbol.prototype.equiv;\n\n    types.Symbol.prototype.com$cognitect$transit$equals = function(other) {\n        return (other instanceof types.Symbol) && this._name == other._name;\n    };\n\n    types.Symbol.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.hashCode === -1) {\n            this.hashCode = eq.hashCode(this._name);\n        }\n        return this.hashCode;\n    };\n\n    types.symbol = function(s) {\n        return new types.Symbol(s);\n    };\n\n    types.isSymbol = function(x) {\n        return x instanceof types.Symbol;\n    };\n\n    types.hexFor = function(aLong, sidx, eidx) {\n        var ret   = \"\";\n\n        eidx  = eidx || (sidx+1);\n\n        for(var i=sidx, shift=(7-i)*8, mask=Long.fromInt(0xff).shiftLeft(shift); i < eidx; i++, shift-=8, mask=mask.shiftRightUnsigned(8)) {\n            var s = aLong.and(mask).shiftRightUnsigned(shift).toString(16);\n            if(s.length == 1) {\n                s = \"0\" + s;\n            }\n            ret += s;\n        }\n\n        return ret;\n    };\n\n    /**\n     * @constructor\n     */\n    types.UUID = function Transit$UUID(high, low) {\n        this.high = high;\n        this.low = low;\n        this.hashCode = -1;\n    };\n\n    types.UUID.prototype.getLeastSignificantBits = function() {\n        return this.low;\n    };\n\n    types.UUID.prototype.getMostSignificantBits = function() {\n        return this.high;\n    };\n\n    types.UUID.prototype.toString = function() {\n        var s    = \"\",\n            hi64 = this.high,\n            lo64 = this.low;\n\n        s += types.hexFor(hi64, 0, 4) + \"-\";\n        s += types.hexFor(hi64, 4, 6) + \"-\";\n        s += types.hexFor(hi64, 6, 8) + \"-\";\n        s += types.hexFor(lo64, 0, 2) + \"-\";\n        s += types.hexFor(lo64, 2, 8);\n\n        return s;\n    };\n\n    types.UUID.prototype.equiv = function(other) {\n        return eq.equals(this, other);\n    };\n    types.UUID.prototype[\"equiv\"] = types.UUID.prototype.equiv;\n\n    types.UUID.prototype.com$cognitect$transit$equals = function(other) {\n        return (other instanceof types.UUID) && this.high.equals(other.high) && this.low.equals(other.low);\n    };\n\n    types.UUID.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.hashCode === -1) {\n            // TODO: follow http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/2d585507a41b/src/share/classes/java/util/UUID.java\n            this.hashCode = eq.hashCode(this.toString());\n        }\n        return this.hashCode;\n    };\n\n    types.UUIDfromString = function uuidFromString(s) {\n        s = s.replace(/-/g, \"\");\n\n        var hi64 = null,\n            lo64 = null,\n            hi32 = 0,\n            lo32 = 0,\n            off  = 24,\n            i    = 0;\n\n        for(hi32=0, i=0, off= 24; i < 8; i+=2, off-=8) {\n            hi32 |= (parseInt(s.substring(i,i+2),16) << off);\n        }\n\n        for(lo32=0, i=8, off=24; i < 16; i+=2, off-=8) {\n            lo32 |= (parseInt(s.substring(i,i+2),16) << off);\n        }\n\n        hi64 = Long.fromBits(lo32, hi32);\n\n        for(hi32=0, i=16, off=24; i < 24; i+=2, off-=8) {\n            hi32 |= (parseInt(s.substring(i,i+2),16) << off);\n        }\n\n        for(lo32=0, i=24, off=24; i < 32; i+=2, off-=8) {\n            lo32 |= (parseInt(s.substring(i,i+2),16) << off);\n        }\n\n        lo64 = Long.fromBits(lo32, hi32);\n\n        return new types.UUID(hi64, lo64);\n    };\n\n    types.uuid = function(s) {\n        return types.UUIDfromString(s);\n    };\n\n    types.isUUID = function(x) {\n        return x instanceof types.UUID;\n    };\n\n    types.date = function(s) {\n        s = typeof s === \"number\" ? s : parseInt(s, 10);\n        return new Date(s);\n    };\n\n    types.verboseDate = function(s) {\n        return new Date(s);\n    };\n\n    Date.prototype.com$cognitect$transit$equals = function(other) {\n        if(other instanceof Date) {\n            return this.valueOf() === other.valueOf();\n        } else {\n            return false;\n        }\n    };\n\n    Date.prototype.com$cognitect$transit$hashCode = function() {\n        return this.valueOf();\n    };\n\n    /**\n     * @param {string} str\n     * @param {*=} decoder\n     * @returns {com.cognitect.transit.types.TaggedValue|Uint8Array}\n     */\n    types.binary = function(str, decoder) {\n        if((!decoder || (decoder.preferBuffers !== false)) && (typeof goog.global.Buffer != \"undefined\")) {\n            return new goog.global.Buffer(str, \"base64\");\n        } else if(typeof Uint8Array != \"undefined\") {\n            return util.Base64ToUint8(str);\n        } else {\n            return types.taggedValue(\"b\", str);\n        }\n    };\n\n    types.isBinary = function(x) {\n        if((typeof goog.global.Buffer != \"undefined\") && (x instanceof goog.global.Buffer)) {\n            return true;\n        } else if((typeof Uint8Array != \"undefined\") && (x instanceof Uint8Array)) {\n            return true;\n        } else {\n            return (x instanceof types.TaggedValue) && (x.tag === \"b\");\n        }\n    };\n\n    types.uri = function(s) {\n        return types.taggedValue(\"r\", s);\n    };\n\n    types.isURI = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"r\");\n    };\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.KEYS = 0;\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.VALUES = 1;\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.ENTRIES = 2;\n\n    /**\n     * @constructor\n     */\n    types.TransitArrayMapIterator = function Transit$ArrayMapIterator(entries, type) {\n        this.entries = entries;\n        this.type = type || types.KEYS;\n        this.idx = 0;\n    };\n\n    types.TransitArrayMapIterator.prototype.next = function() {\n        if(this.idx < this.entries.length) {\n\n            var value = null;\n\n            if(this.type === types.KEYS) {\n                value = this.entries[this.idx];\n            } else if(this.type === types.VALUES) {\n                value = this.entries[this.idx+1];\n            } else {\n                value = [this.entries[this.idx], this.entries[this.idx+1]];\n            }\n\n            var ret = {\n                \"value\": value,\n                \"done\": false\n            };\n\n            this.idx+=2;\n\n            return ret;\n        } else {\n            return {\"value\": null, \"done\": true}\n        }\n    };\n    types.TransitArrayMapIterator.prototype[\"next\"] = types.TransitArrayMapIterator.prototype.next;\n\n    types.TransitArrayMapIterator.prototype[types.ITERATOR] = function() {\n        return this;\n    };\n\n    /**\n     * @constructor\n     */\n    types.TransitMapIterator = function Transit$MapIterator(map, type) {\n        this.map = map;\n        this.type = type || types.KEYS;\n        this.keys = this.map.getKeys();\n        this.idx = 0;\n        /** @type {?Object} */\n        this.bucket = null;\n        this.bucketIdx = 0;\n    };\n\n    types.TransitMapIterator.prototype.next = function() {\n        if(this.idx < this.map.size) {\n            if((this.bucket == null) || !(this.bucketIdx < this.bucket.length)) {\n                this.bucket = this.map.map[this.keys[this.idx]];\n                this.bucketIdx = 0;\n            }\n\n            var value = null;\n            if(this.type === types.KEYS) {\n                value = this.bucket[this.bucketIdx];\n            } else if(this.type === types.VALUES) {\n                value = this.bucket[this.bucketIdx+1];\n            } else {\n                value = [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx+1]];\n            }\n\n            var ret = {\n                \"value\": value,\n                \"done\": false\n            };\n\n            this.idx++;\n            this.bucketIdx+=2;\n\n            return ret;\n        } else {\n            return {\"value\": null, \"done\": true};\n        }\n    };\n    types.TransitMapIterator.prototype[\"next\"] = types.TransitMapIterator.prototype.next;\n\n    types.TransitMapIterator.prototype[types.ITERATOR] = function() {\n        return this;\n    };\n\n    types.mapEquals = function(me, you) {\n        if ((me instanceof types.TransitMap) && types.isMap(you)) {\n            if(me.size !== you.size) return false;\n            for (var code in me.map) {\n                var bucket = me.map[code];\n                for (var j = 0; j < bucket.length; j+=2) {\n                    if (!eq.equals(bucket[j+1], you.get(bucket[j]))) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        } else if((me instanceof types.TransitArrayMap) && types.isMap(you)) {\n            if(me.size !== you.size) return false;\n            var entries = me._entries;\n            for (var j = 0; j < entries.length; j+=2) {\n                if (!eq.equals(entries[j+1], you.get(entries[j]))) {\n                    return false;\n                }\n            }\n            return true;\n        } else if(you != null && (typeof you === \"object\")) {\n            var ks    = util.objectKeys(you),\n                kslen = ks.length;\n            if(me.size === kslen) {\n                for(var i = 0 ; i < kslen; i++) {\n                    var k = ks[i];\n                    if(!me.has(k) || !eq.equals(you[k], me.get(k))) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.SMALL_ARRAY_MAP_THRESHOLD = 8;\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.ARRAY_MAP_THRESHOLD = 32;\n\n    /**\n     * @const\n     * @type {number}\n     */\n    types.ARRAY_MAP_ACCESS_THRESHOLD = 32;\n\n    types.print = function(x) {\n        if(x == null) {\n            return \"null\";\n        } if(goog.typeOf(x) === \"array\") {\n            return \"[\" + x.toString() + \"]\";\n        } else if(goog.typeOf(x) === \"string\") {\n            return \"\\\"\" + x + \"\\\"\";\n        } else {\n            return x.toString();\n        }\n    };\n\n    types.printMap = function(map) {\n        var idx = 0,\n            str = \"TransitMap {\";\n        map.forEach(function(v, k) {\n            str += types.print(k) + \" => \" + types.print(v);\n            if(idx < map.size-1) {\n                str += \", \";\n            }\n            idx++;\n        });\n        return str + \"}\";\n    };\n\n    types.printSet = function(set) {\n        var idx  = 0,\n            str  = \"TransitSet {\";\n        set.forEach(function(v) {\n            str += types.print(v);\n            if(idx < set.size-1) {\n                str += \", \";\n            }\n            idx++;\n        });\n        return str + \"}\";\n    };\n\n    /**\n     * @constructor\n     * @param {Array} entries\n     */\n    types.TransitArrayMap = function Transit$ArrayMap(entries) {\n        this._entries = entries;\n        this.backingMap = null;\n        this.hashCode = -1;\n        this.size = entries.length / 2;\n        this.accesses = 0;\n    };\n\n    types.TransitArrayMap.prototype.toString = function() {\n        return types.printMap(this);\n    };\n\n    types.TransitArrayMap.prototype[\"inspect\"] = function() {\n        return this.toString();\n    };\n\n    types.TransitArrayMap.prototype.convert = function() {\n        if(this.backingMap) {\n            throw Error(\"Invalid operation, already converted\");\n        }\n        if(this.size < types.SMALL_ARRAY_MAP_THRESHOLD) return false;\n        this.accesses++;\n        if(this.accesses > types.ARRAY_MAP_ACCESS_THRESHOLD) {\n            this.backingMap = types.map(this._entries, false, true);\n            this._entries = [];\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    types.TransitArrayMap.prototype.clear = function() {\n        this.hashCode = -1;\n        if(this.backingMap) {\n            this.backingMap.clear();\n            this.size = 0;\n        } else {\n            this._entries = [];\n            this.size = 0;\n        }\n    };\n    types.TransitArrayMap.prototype[\"clear\"] = types.TransitArrayMap.prototype.clear;\n\n    types.TransitArrayMap.prototype.keys = function() {\n        if(this.backingMap) {\n            return this.backingMap.keys();\n        } else {\n            return new types.TransitArrayMapIterator(this._entries, types.KEYS);\n        }\n    };\n    types.TransitArrayMap.prototype[\"keys\"] = types.TransitArrayMap.prototype.keys;\n\n    types.TransitArrayMap.prototype.keySet = function() {\n        if(this.backingMap) {\n            return this.backingMap.keySet();\n        } else {\n            var ret = [];\n            for(var i = 0, j = 0; j < this._entries.length; i++, j+=2) {\n                ret[i] = this._entries[j];\n            }\n            return ret;\n        }\n    };\n    types.TransitArrayMap.prototype[\"keySet\"] = types.TransitArrayMap.prototype.keySet;\n\n    types.TransitArrayMap.prototype.entries = function() {\n        if(this.backingMap) {\n            return this.backingMap.entries();\n        } else {\n            return new types.TransitArrayMapIterator(this._entries, types.ENTRIES);\n        }\n    };\n    types.TransitArrayMap.prototype[\"entries\"] = types.TransitArrayMap.prototype.entries;\n\n    types.TransitArrayMap.prototype.values = function() {\n        if(this.backingMap) {\n            return this.backingMap.values();\n        } else {\n            return new types.TransitArrayMapIterator(this._entries, types.VALUES);\n        }\n    };\n    types.TransitArrayMap.prototype[\"values\"] = types.TransitArrayMap.prototype.values;\n\n    /**\n     * @param {function(*,*)} f\n     */\n    types.TransitArrayMap.prototype.forEach = function(f) {\n        if(this.backingMap) {\n            this.backingMap.forEach(f);\n        } else {\n            for(var i = 0; i < this._entries.length; i+=2) {\n                f(this._entries[i+1], this._entries[i]);\n            }\n        }\n    };\n    types.TransitArrayMap.prototype[\"forEach\"] = types.TransitArrayMap.prototype.forEach;\n\n    /**\n     * @param {*} k\n     * @param {*=} notFound\n     * @returns {*}\n     */\n    types.TransitArrayMap.prototype.get = function(k, notFound) {\n        if(this.backingMap) {\n            return this.backingMap.get(k);\n        } else {\n            if(this.convert()) {\n                return this.get(k);\n            } else {\n                for(var i = 0; i < this._entries.length; i+=2) {\n                    if(eq.equals(this._entries[i], k)) {\n                        return this._entries[i+1];\n                    }\n                }\n                return notFound;\n            }\n        }\n    };\n    types.TransitArrayMap.prototype[\"get\"] = types.TransitArrayMap.prototype.get;\n\n    types.TransitArrayMap.prototype.has = function(k) {\n        if(this.backingMap) {\n            return this.backingMap.has(k);\n        } else {\n            if(this.convert()) {\n                return this.has(k);\n            } else {\n                for(var i = 0; i < this._entries.length; i+=2) {\n                    if(eq.equals(this._entries[i], k)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    };\n    types.TransitArrayMap.prototype[\"has\"] = types.TransitArrayMap.prototype.has;\n\n    types.TransitArrayMap.prototype.set = function(k, v) {\n        this.hashCode = -1;\n        if(this.backingMap) {\n            this.backingMap.set(k, v);\n            this.size = this.backingMap.size;\n        } else {\n            for(var i = 0; i < this._entries.length; i+=2) {\n                if(eq.equals(this._entries[i], k)) {\n                    this._entries[i+1] = v;\n                    return;\n                }\n            }\n\n            this._entries.push(k);\n            this._entries.push(v);\n            this.size++;\n\n            if(this.size > types.ARRAY_MAP_THRESHOLD) {\n                this.backingMap = types.map(this._entries, false, true);\n                this._entries = null;\n            }\n        }\n    };\n    types.TransitArrayMap.prototype[\"set\"] = types.TransitArrayMap.prototype.set;\n\n    types.TransitArrayMap.prototype[\"delete\"] = function(k) {\n        this.hashCode = -1;\n        if(this.backingMap) {\n            var ret = this.backingMap.delete(k);\n            this.size = this.backingMap.size;\n            return ret;\n        } else {\n            for(var i = 0; i < this._entries.length; i+=2) {\n                if(eq.equals(this._entries[i], k)) {\n                    var ret = this._entries[i+1];\n                    this._entries.splice(i, 2);\n                    this.size--;\n                    return ret;\n                }\n            }\n        }\n    };\n\n    types.TransitArrayMap.prototype.clone = function() {\n        var clone = types.map();\n\n        this.forEach(function(v, k) {\n            clone.set(k, v);\n        });\n\n        return clone;\n    };\n    types.TransitArrayMap.prototype[\"clone\"] = types.TransitArrayMap.prototype.clone;\n\n    types.TransitArrayMap.prototype[types.ITERATOR] = function() {\n        return this.entries();\n    };\n\n    types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.backingMap) {\n            return this.backingMap.com$cognitect$transit$hashCode();\n        } else {\n            if(this.hashCode === -1) {\n                this.hashCode = eq.hashMapLike(this);\n            }\n            return this.hashCode;\n        }\n    };\n\n    types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(other) {\n        if(this.backingMap) {\n            return types.mapEquals(this.backingMap, other);\n        } else {\n            return types.mapEquals(this, other);\n        }\n    };\n\n    /**\n     * TransitMap\n     *   A hash map. Support arbitrarily complex keys. Lookup is based on the value of the\n     *   the key not identity. Otherwise the API follows the ES6 map interface:\n     *   http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n     * @constructor\n     * @param {null|Array=} keys\n     * @param {null|Object=} map\n     * @param {null|number=} size\n     */\n    types.TransitMap = function Transit$Map(keys, map, size) {\n        this.map = map || {};\n        this._keys = keys || [];\n        this.size = size || 0;\n        this.hashCode = -1;\n    };\n\n    types.TransitMap.prototype.toString = function() {\n        return types.printMap(this);\n    };\n\n    types.TransitMap.prototype[\"inspect\"] = function() {\n        return this.toString();\n    };\n\n    types.TransitMap.prototype.clear = function() {\n        this.hashCode = -1;\n        this.map = {};\n        this._keys = [];\n        this.size = 0;\n    };\n    types.TransitMap.prototype[\"clear\"] = types.TransitMap.prototype.clear;\n\n    types.TransitMap.prototype.getKeys = function() {\n        if(this._keys != null) {\n            return this._keys;\n        } else {\n            return util.objectKeys(this.map);\n        }\n    };\n\n    types.TransitMap.prototype[\"delete\"] = function(k) {\n        this.hashCode = -1;\n        this._keys = null;\n        var code   = eq.hashCode(k),\n            bucket = this.map[code];\n\n        for(var i = 0; i < bucket.length; i+=2) {\n            if(eq.equals(k, bucket[i])) {\n                var ret = bucket[i+1];\n                bucket.splice(i,2);\n                if(bucket.length === 0) {\n                    delete this.map[code];\n                }\n                this.size--;\n                return ret;\n            }\n        }\n    };\n\n    types.TransitMap.prototype.entries = function() {\n        return new types.TransitMapIterator(this, types.ENTRIES);\n    };\n    types.TransitMap.prototype[\"entries\"] = types.TransitMap.prototype.entries;\n\n    types.TransitMap.prototype.forEach = function(callback) {\n        var ks = this.getKeys();\n        for(var i = 0; i < ks.length; i++) {\n            var bucket = this.map[ks[i]];\n            for(var j = 0; j < bucket.length; j+=2) {\n                callback(bucket[j+1], bucket[j], this);\n            }\n        }\n    };\n    types.TransitMap.prototype[\"forEach\"] = types.TransitMap.prototype.forEach;\n\n    types.TransitMap.prototype.get = function(k, notFound) {\n        var code   = eq.hashCode(k),\n            bucket = this.map[code];\n        if(bucket != null) {\n            for(var i = 0; i < bucket.length; i+=2) {\n                if(eq.equals(k,bucket[i])) {\n                    return bucket[i+1];\n                }\n            }\n        } else {\n            return notFound;\n        }\n    };\n    types.TransitMap.prototype[\"get\"] = types.TransitMap.prototype.get;\n\n    types.TransitMap.prototype.has = function(k) {\n        var code   = eq.hashCode(k),\n            bucket = this.map[code];\n        if(bucket != null) {\n            for(var i = 0; i < bucket.length; i+=2) {\n                if(eq.equals(k, bucket[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return false;\n        }\n    };\n    types.TransitMap.prototype[\"has\"] = types.TransitMap.prototype.has;\n\n    types.TransitMap.prototype.keys = function() {\n        return new types.TransitMapIterator(this, types.KEYS);\n    };\n    types.TransitMap.prototype[\"keys\"] = types.TransitMap.prototype.keys;\n\n    types.TransitMap.prototype.keySet = function() {\n        var keys = this.getKeys(),\n            ret  = [];\n\n        for(var i = 0; i < keys.length; i++) {\n            var bucket = this.map[keys[i]];\n            for(var j = 0; j < bucket.length; j+=2) {\n                ret.push(bucket[j]);\n            }\n        }\n\n        return ret;\n    };\n    types.TransitMap.prototype[\"keySet\"] = types.TransitMap.prototype.keySet;\n\n    types.TransitMap.prototype.set = function(k, v) {\n        this.hashCode = -1;\n        var code = eq.hashCode(k),\n            bucket = this.map[code];\n        if(bucket == null) {\n            if(this._keys) {\n                this._keys.push(code);\n            }\n            this.map[code] = [k, v];\n            this.size++;\n        } else {\n            var newEntry = true;\n            for(var i = 0; i < bucket.length; i+=2) {\n                if(eq.equals(v, bucket[i])) {\n                    newEntry = false;\n                    bucket[i] = v;\n                    break;\n                }\n            }\n            if(newEntry) {\n                bucket.push(k);\n                bucket.push(v);\n                this.size++;\n            }\n        }\n    };\n    types.TransitMap.prototype[\"set\"] = types.TransitMap.prototype.set;\n\n    types.TransitMap.prototype.values = function() {\n        return new types.TransitMapIterator(this, types.VALUES);\n    };\n    types.TransitMap.prototype[\"values\"] = types.TransitMap.prototype.values;\n\n    types.TransitMap.prototype.clone = function() {\n        var clone = types.map();\n\n        this.forEach(function(v, k) {\n           clone.set(k, v);\n        });\n\n        return clone;\n    };\n    types.TransitMap.prototype[\"clone\"] = types.TransitMap.prototype.clone;\n\n    types.TransitMap.prototype[types.ITERATOR] = function() {\n        return this.entries();\n    };\n\n    types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {\n        if(this.hashCode === -1) {\n            this.hashCode = eq.hashMapLike(this);\n        }\n        return this.hashCode;\n    };\n\n    types.TransitMap.prototype.com$cognitect$transit$equals = function(other) {\n        return types.mapEquals(this, other);\n    };\n\n    /**\n     * @param {Array=} arr\n     * @param {boolean=} checkDups\n     * @param {boolean=} hashMap\n     * @returns {com.cognitect.transit.MapLike}\n     */\n    types.map = function(arr, checkDups, hashMap) {\n        arr = arr || [];\n        checkDups = (checkDups === false) ? checkDups : true;\n        hashMap = (hashMap === true) ? hashMap : false;\n\n        if(!hashMap && (arr.length <= (types.ARRAY_MAP_THRESHOLD*2))) {\n            if(checkDups) {\n                var t = arr;\n                arr = [];\n                for(var i = 0; i < t.length; i+=2) {\n                    var seen = false;\n                    for(var j = 0; j < arr.length; j+=2) {\n                        if(eq.equals(arr[j], t[i])) {\n                            arr[j+1] = t[i+1];\n                            seen = true;\n                            break;\n                        }\n                    }\n                    if(!seen) {\n                        arr.push(t[i]);\n                        arr.push(t[i+1]);\n                    }\n                }\n            }\n            return new types.TransitArrayMap(arr);\n        } else {\n            var map  = {},\n                keys = [],\n                size = 0;\n            for(var i = 0; i < arr.length; i+=2) {\n                var code = eq.hashCode(arr[i]),\n                    bucket = map[code];\n                if(bucket == null) {\n                    keys.push(code);\n                    map[code] = [arr[i], arr[i+1]];\n                    size++;\n                } else {\n                    var newEntry = true;\n                    for(var j = 0; j < bucket.length; j+= 2) {\n                        if(eq.equals(bucket[j], arr[i])) {\n                            bucket[j+1] = arr[i+1];\n                            newEntry = false;\n                            break;\n                        }\n                    }\n                    if(newEntry) {\n                        bucket.push(arr[i]);\n                        bucket.push(arr[i+1]);\n                        size++;\n                    }\n                }\n            }\n            return new types.TransitMap(keys, map, size);\n        }\n    };\n\n    types.isArrayMap = function(x) {\n        return (x instanceof types.TransitArrayMap);\n    };\n\n    types.isMap = function(x) {\n        return ((x instanceof types.TransitArrayMap) ||\n                (x instanceof types.TransitMap));\n    };\n\n    /**\n     * @constructor\n     * @param {com.cognitect.transit.MapLike} map\n     */\n    types.TransitSet = function Transit$Set(map) {\n        this.map = map;\n        this.size = map.size;\n    };\n\n    types.TransitSet.prototype.toString = function() {\n        return types.printSet(this);\n    };\n\n    types.TransitSet.prototype[\"inspect\"] = function() {\n        return this.toString();\n    };\n\n    types.TransitSet.prototype.add = function(value) {\n        this.map.set(value, value);\n        this.size = this.map.size;\n    };\n    types.TransitSet.prototype[\"add\"] = types.TransitSet.prototype.add;\n\n    types.TransitSet.prototype.clear = function() {\n        this.map = new types.TransitMap();\n        this.size = 0;\n    };\n    types.TransitSet.prototype[\"clear\"] = types.TransitSet.prototype.clear;\n\n    types.TransitSet.prototype[\"delete\"] = function(value) {\n        var ret = this.map.delete(value);\n        this.size = this.map.size;\n        return ret;\n    };\n\n    types.TransitSet.prototype.entries = function() {\n        return this.map.entries();\n    };\n    types.TransitSet.prototype[\"entries\"] = types.TransitSet.prototype.entries;\n\n    /**\n     * @param {function(*,*)} iterator\n     * @param {Object=} thisArg\n     */\n    types.TransitSet.prototype.forEach = function(iterator, thisArg) {\n        var self = this;\n        this.map.forEach(function(v, k, m) {\n            iterator(k, self);\n        });\n    };\n    types.TransitSet.prototype[\"forEach\"] = types.TransitSet.prototype.forEach;\n\n    types.TransitSet.prototype.has = function(value) {\n        return this.map.has(value);\n    };\n    types.TransitSet.prototype[\"has\"] = types.TransitSet.prototype.has;\n\n    types.TransitSet.prototype.keys = function() {\n        return this.map.keys();\n    };\n    types.TransitSet.prototype[\"keys\"] = types.TransitSet.prototype.keys;\n\n    types.TransitSet.prototype.keySet = function() {\n        return this.map.keySet();\n    };\n    types.TransitSet.prototype[\"keySet\"] = types.TransitSet.prototype.keySet;\n\n    types.TransitSet.prototype.values = function() {\n        return this.map.values();\n    };\n    types.TransitSet.prototype[\"values\"] = types.TransitSet.prototype.values;\n\n    types.TransitSet.prototype.clone = function() {\n        var clone = types.set();\n\n        this.forEach(function(k) {\n            clone.add(k);\n        });\n\n        return clone;\n    };\n    types.TransitSet.prototype[\"clone\"] = types.TransitSet.prototype.clone;\n\n    types.TransitSet.prototype[types.ITERATOR] = function() {\n        return this.values();\n    };\n\n    types.TransitSet.prototype.com$cognitect$transit$equals = function(other) {\n        if(other instanceof types.TransitSet) {\n            if(this.size === other.size) {\n                return eq.equals(this.map, other.map);\n            }\n        } else {\n            return false;\n        }\n    };\n\n    types.TransitSet.prototype.com$cognitect$transit$hashCode = function(other) {\n        return eq.hashCode(this.map);\n    };\n\n    /**\n     * @param {Array=} arr\n     * @returns {com.cognitect.transit.SetLike}\n     */\n    types.set = function(arr) {\n        arr = arr || [];\n\n        var map  = {},\n            keys = [],\n            size = 0;\n\n        for(var i = 0; i < arr.length; i++) {\n            var code = eq.hashCode(arr[i]),\n                vals = map[code];\n            if(vals == null) {\n                keys.push(code);\n                map[code] = [arr[i], arr[i]];\n                size++\n            } else {\n                var newEntry = true;\n                for(var j = 0; j < vals.length; j+= 2) {\n                    if(eq.equals(vals[j], arr[i])) {\n                        newEntry = false;\n                        break;\n                    }\n                }\n                if(newEntry) {\n                    vals.push(arr[i]);\n                    vals.push(arr[i]);\n                    size++;\n                }\n            }\n        }\n\n        return new types.TransitSet(new types.TransitMap(keys, map, size));\n    };\n\n    types.isSet = function(x) {\n        return x instanceof types.TransitSet;\n    };\n\n    types.quoted = function(obj) {\n        return types.taggedValue(\"'\", obj);\n    };\n\n    types.isQuoted = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"'\");\n    };\n\n    types.list = function(xs) {\n        return types.taggedValue(\"list\", xs);\n    };\n\n    types.isList = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"list\");\n    };\n\n    types.link = function(rep) {\n        return types.taggedValue(\"link\", rep);\n    };\n\n    types.isLink = function(x) {\n        return (x instanceof types.TaggedValue) && (x.tag === \"link\")\n    };\n\n    types.specialDouble = function(v) {\n        switch(v) {\n            case \"-INF\":\n                return -Infinity;\n            case \"INF\":\n                return Infinity;\n            case \"NaN\":\n                return NaN;\n            default:\n                throw new Error(\"Invalid special double value \" + v);\n                break;\n        }\n    };\n\n});\n\n","~:compiled-at",1668873222578,"~:source-map-json","{\n\"version\":3,\n\"file\":\"com.cognitect.transit.types.js\",\n\"lineCount\":1,\n\"mappings\":\";\",\n\"sources\":[],\n\"names\":[]\n}\n"]