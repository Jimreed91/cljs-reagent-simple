["^ ","~:resource-id",["~:shadow.build.classpath/resource","com/cognitect/transit/eq.js"],"~:js","goog.provide(\"com.cognitect.transit.eq\");\ngoog.require(\"com.cognitect.transit.util\");\ngoog.scope(function() {\n  var eq = com.cognitect.transit.eq, util = com.cognitect.transit.util;\n  eq.hashCodeProperty = \"transit$hashCode$\";\n  eq.hashCodeCounter = 1;\n  eq.equals = function(x, y) {\n    if (x == null) {\n      return y == null;\n    } else if (x === y) {\n      return true;\n    } else if (typeof x === \"object\") {\n      if (util.isArray(x)) {\n        if (util.isArray(y)) {\n          if (x.length === y.length) {\n            for (var i = 0; i < x.length; i++) {\n              if (!eq.equals(x[i], y[i])) {\n                return false;\n              }\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      } else if (x.com$cognitect$transit$equals) {\n        return x.com$cognitect$transit$equals(y);\n      } else if (y != null && typeof y === \"object\") {\n        if (y.com$cognitect$transit$equals) {\n          return y.com$cognitect$transit$equals(x);\n        } else {\n          var xklen = 0, yklen = util.objectKeys(y).length;\n          for (var p in x) {\n            if (!x.hasOwnProperty(p)) {\n              continue;\n            }\n            xklen++;\n            if (!y.hasOwnProperty(p)) {\n              return false;\n            } else {\n              if (!eq.equals(x[p], y[p])) {\n                return false;\n              }\n            }\n          }\n          return xklen === yklen;\n        }\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n  eq.hashCombine = function(seed, hash) {\n    return seed ^ hash + 2654435769 + (seed << 6) + (seed >> 2);\n  };\n  eq.stringCodeCache = {};\n  eq.stringCodeCacheSize = 0;\n  eq.STR_CACHE_MAX = 256;\n  eq.hashString = function(str) {\n    var cached = eq.stringCodeCache[str];\n    if (cached != null) {\n      return cached;\n    }\n    var code = 0;\n    for (var i = 0; i < str.length; ++i) {\n      code = 31 * code + str.charCodeAt(i);\n      code %= 4294967296;\n    }\n    eq.stringCodeCacheSize++;\n    if (eq.stringCodeCacheSize >= eq.STR_CACHE_MAX) {\n      eq.stringCodeCache = {};\n      eq.stringCodeCacheSize = 1;\n    }\n    eq.stringCodeCache[str] = code;\n    return code;\n  };\n  eq.hashMapLike = function(m) {\n    var code = 0;\n    if (m.forEach != null) {\n      m.forEach(function(val, key, m) {\n        code = (code + (eq.hashCode(key) ^ eq.hashCode(val))) % 4503599627370496;\n      });\n    } else {\n      var keys = util.objectKeys(m);\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var val = m[key];\n        code = (code + (eq.hashCode(key) ^ eq.hashCode(val))) % 4503599627370496;\n      }\n    }\n    return code;\n  };\n  eq.hashArrayLike = function(arr) {\n    var code = 0;\n    if (util.isArray(arr)) {\n      for (var i = 0; i < arr.length; i++) {\n        code = eq.hashCombine(code, eq.hashCode(arr[i]));\n      }\n    } else if (arr.forEach) {\n      arr.forEach(function(x, i) {\n        code = eq.hashCombine(code, eq.hashCode(x));\n      });\n    }\n    return code;\n  };\n  eq.hashCode = function(x) {\n    if (x == null) {\n      return 0;\n    } else {\n      switch(typeof x) {\n        case \"number\":\n          return x;\n          break;\n        case \"boolean\":\n          return x === true ? 1 : 0;\n          break;\n        case \"string\":\n          return eq.hashString(x);\n          break;\n        case \"function\":\n          var code = x[eq.hashCodeProperty];\n          if (code) {\n            return code;\n          } else {\n            code = eq.hashCodeCounter;\n            if (typeof Object.defineProperty != \"undefined\") {\n              Object.defineProperty(x, eq.hashCodeProperty, {value:code, enumerable:false});\n            } else {\n              x[eq.hashCodeProperty] = code;\n            }\n            eq.hashCodeCounter++;\n            return code;\n          }\n          break;\n        default:\n          if (x instanceof Date) {\n            return x.valueOf();\n          } else if (util.isArray(x)) {\n            return eq.hashArrayLike(x);\n          }\n          if (x.com$cognitect$transit$hashCode) {\n            return x.com$cognitect$transit$hashCode();\n          } else {\n            return eq.hashMapLike(x);\n          }\n          break;\n      }\n    }\n  };\n  eq.extendToEQ = function(obj, opts) {\n    obj.com$cognitect$transit$hashCode = opts[\"hashCode\"];\n    obj.com$cognitect$transit$equals = opts[\"equals\"];\n    return obj;\n  };\n});\n","~:source","// Copyright 2014 Cognitect. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide(\"com.cognitect.transit.eq\");\ngoog.require(\"com.cognitect.transit.util\");\n\ngoog.scope(function() {\n\nvar eq   = com.cognitect.transit.eq,\n    util = com.cognitect.transit.util;\n\n/**\n * @const\n * @type {string}\n */\neq.hashCodeProperty = \"transit$hashCode$\";\n\n/**\n * @type {number}\n */\neq.hashCodeCounter = 1;\n\neq.equals = function (x, y) {\n    if(x == null) {\n        return y == null;\n    } else if(x === y) {\n        return true;\n    } else if(typeof x === \"object\") {\n        if(util.isArray(x)) {\n            if(util.isArray(y)) {\n                if(x.length === y.length) {\n                    for(var i = 0; i < x.length; i++) {\n                        if(!eq.equals(x[i], y[i])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if(x.com$cognitect$transit$equals) {\n            return x.com$cognitect$transit$equals(y);\n        } else if((y != null) && (typeof y === \"object\")) {\n            if(y.com$cognitect$transit$equals) {\n                return y.com$cognitect$transit$equals(x);\n            } else {\n                var xklen = 0,\n                    yklen = util.objectKeys(y).length;\n                for(var p in x) {\n                    if(!x.hasOwnProperty(p)) continue;\n                    xklen++;\n                    if(!y.hasOwnProperty(p)) {\n                        return false;\n                    } else {\n                        if(!eq.equals(x[p], y[p])) {\n                            return false;\n                        }\n                    }\n                }\n                return xklen === yklen;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false\n    }\n};\n\neq.hashCombine = function(seed, hash) {\n    return seed ^ (hash + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n};\n\neq.stringCodeCache     = {};\neq.stringCodeCacheSize = 0;\n\n/**\n * @const\n * @type {number}\n */\neq.STR_CACHE_MAX       = 256;\n\neq.hashString = function(str) {\n    // a la goog.string.HashCode\n    // http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1206\n    var cached = eq.stringCodeCache[str];\n    if(cached != null) {\n        return cached;\n    }\n    var code = 0;\n    for (var i = 0; i < str.length; ++i) {\n        code = 31 * code + str.charCodeAt(i);\n        code %= 0x100000000;\n    }\n    eq.stringCodeCacheSize++;\n    if(eq.stringCodeCacheSize >= eq.STR_CACHE_MAX) {\n        eq.stringCodeCache = {};\n        eq.stringCodeCacheSize = 1;\n    }\n    eq.stringCodeCache[str] = code;\n    return code;\n};\n\neq.hashMapLike = function(m) {\n    var code = 0;\n    // ES6 Map-like case\n    if(m.forEach != null) {\n        m.forEach(function(val, key, m) {\n            code = (code + (eq.hashCode(key) ^ eq.hashCode(val))) % 4503599627370496;\n        });\n    } else {\n        // JS Object case\n        var keys = util.objectKeys(m);\n        for(var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var val = m[key];\n            code = (code + (eq.hashCode(key) ^ eq.hashCode(val))) % 4503599627370496;\n        }\n    }\n    return code;\n};\n\neq.hashArrayLike = function(arr) {\n    var code = 0;\n    if(util.isArray(arr)) {\n        for(var i = 0; i < arr.length; i++) {\n            code = eq.hashCombine(code, eq.hashCode(arr[i]));\n        }\n    } else if(arr.forEach) {\n        arr.forEach(function(x, i) {\n            code = eq.hashCombine(code, eq.hashCode(x));\n        });\n    }\n    return code;\n};\n\neq.hashCode = function(x) {\n    if(x == null) {\n        return 0;\n    } else {\n        switch(typeof x) {\n        case 'number':\n            return x;\n            break;\n        case 'boolean':\n            return x === true ? 1 : 0;\n            break;\n        case 'string':\n            return eq.hashString(x);\n            break;\n        case 'function':\n            var code = x[eq.hashCodeProperty];\n            if(code) {\n                return code;\n            } else {\n                code = eq.hashCodeCounter;\n                if(typeof Object.defineProperty != \"undefined\") {\n                    Object.defineProperty(x, eq.hashCodeProperty, {\n                        value: code,\n                        enumerable: false\n                    });\n                } else {\n                    x[eq.hashCodeProperty] = code;\n                }\n                eq.hashCodeCounter++;    \n                return code;\n            }\n            break;\n        default:\n            if(x instanceof Date) {\n                return x.valueOf();\n            } else if(util.isArray(x)) {\n                return eq.hashArrayLike(x);\n            } if(x.com$cognitect$transit$hashCode) {\n                return x.com$cognitect$transit$hashCode();\n            } else {\n                return eq.hashMapLike(x);\n            }\n            break;\n        }\n    }\n}\n\neq.extendToEQ = function(obj, opts) {\n    obj.com$cognitect$transit$hashCode = opts[\"hashCode\"];\n    obj.com$cognitect$transit$equals = opts[\"equals\"];\n    return obj;\n}\n\n});\n","~:compiled-at",1668873222552,"~:source-map-json","{\n\"version\":3,\n\"file\":\"com.cognitect.transit.eq.js\",\n\"lineCount\":1,\n\"mappings\":\";\",\n\"sources\":[],\n\"names\":[]\n}\n"]