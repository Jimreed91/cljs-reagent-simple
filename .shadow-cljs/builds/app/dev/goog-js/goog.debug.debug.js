["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/debug/debug.js"],"~:js","goog.provide(\"goog.debug\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.debug.errorcontext\");\ngoog.debug.LOGGING_ENABLED = goog.define(\"goog.debug.LOGGING_ENABLED\", goog.DEBUG);\ngoog.debug.FORCE_SLOPPY_STACKS = goog.define(\"goog.debug.FORCE_SLOPPY_STACKS\", false);\ngoog.debug.CHECK_FOR_THROWN_EVENT = goog.define(\"goog.debug.CHECK_FOR_THROWN_EVENT\", false);\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\n  var target = opt_target || goog.global;\n  var oldErrorHandler = target.onerror;\n  var retVal = !!opt_cancel;\n  target.onerror = function(message, url, line, opt_col, opt_error) {\n    if (oldErrorHandler) {\n      oldErrorHandler(message, url, line, opt_col, opt_error);\n    }\n    logFunc({message:message, fileName:url, line:line, lineNumber:line, col:opt_col, error:opt_error});\n    return retVal;\n  };\n};\ngoog.debug.expose = function(obj, opt_showFn) {\n  if (typeof obj == \"undefined\") {\n    return \"undefined\";\n  }\n  if (obj == null) {\n    return \"NULL\";\n  }\n  var str = [];\n  for (var x in obj) {\n    if (!opt_showFn && typeof obj[x] === \"function\") {\n      continue;\n    }\n    var s = x + \" \\x3d \";\n    try {\n      s += obj[x];\n    } catch (e) {\n      s += \"*** \" + e + \" ***\";\n    }\n    str.push(s);\n  }\n  return str.join(\"\\n\");\n};\ngoog.debug.deepExpose = function(obj, opt_showFn) {\n  var str = [];\n  var uidsToCleanup = [];\n  var ancestorUids = {};\n  var helper = function(obj, space) {\n    var nestspace = space + \"  \";\n    var indentMultiline = function(str) {\n      return str.replace(/\\n/g, \"\\n\" + space);\n    };\n    try {\n      if (obj === undefined) {\n        str.push(\"undefined\");\n      } else if (obj === null) {\n        str.push(\"NULL\");\n      } else if (typeof obj === \"string\") {\n        str.push('\"' + indentMultiline(obj) + '\"');\n      } else if (typeof obj === \"function\") {\n        str.push(indentMultiline(String(obj)));\n      } else if (goog.isObject(obj)) {\n        if (!goog.hasUid(obj)) {\n          uidsToCleanup.push(obj);\n        }\n        var uid = goog.getUid(obj);\n        if (ancestorUids[uid]) {\n          str.push(\"*** reference loop detected (id\\x3d\" + uid + \") ***\");\n        } else {\n          ancestorUids[uid] = true;\n          str.push(\"{\");\n          for (var x in obj) {\n            if (!opt_showFn && typeof obj[x] === \"function\") {\n              continue;\n            }\n            str.push(\"\\n\");\n            str.push(nestspace);\n            str.push(x + \" \\x3d \");\n            helper(obj[x], nestspace);\n          }\n          str.push(\"\\n\" + space + \"}\");\n          delete ancestorUids[uid];\n        }\n      } else {\n        str.push(obj);\n      }\n    } catch (e) {\n      str.push(\"*** \" + e + \" ***\");\n    }\n  };\n  helper(obj, \"\");\n  for (var i = 0; i < uidsToCleanup.length; i++) {\n    goog.removeUid(uidsToCleanup[i]);\n  }\n  return str.join(\"\");\n};\ngoog.debug.exposeArray = function(arr) {\n  var str = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      str.push(goog.debug.exposeArray(arr[i]));\n    } else {\n      str.push(arr[i]);\n    }\n  }\n  return \"[ \" + str.join(\", \") + \" ]\";\n};\ngoog.debug.normalizeErrorObject = function(err) {\n  var href = goog.getObjectByName(\"window.location.href\");\n  if (err == null) {\n    err = 'Unknown Error of type \"null/undefined\"';\n  }\n  if (typeof err === \"string\") {\n    return {\"message\":err, \"name\":\"Unknown error\", \"lineNumber\":\"Not available\", \"fileName\":href, \"stack\":\"Not available\"};\n  }\n  var lineNumber, fileName;\n  var threwError = false;\n  try {\n    lineNumber = err.lineNumber || err.line || \"Not available\";\n  } catch (e) {\n    lineNumber = \"Not available\";\n    threwError = true;\n  }\n  try {\n    fileName = err.fileName || err.filename || err.sourceURL || goog.global[\"$googDebugFname\"] || href;\n  } catch (e) {\n    fileName = \"Not available\";\n    threwError = true;\n  }\n  var stack = goog.debug.serializeErrorStack_(err);\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack || !err.message || !err.name) {\n    var message = err.message;\n    if (message == null) {\n      if (err.constructor && err.constructor instanceof Function) {\n        var ctorName = err.constructor.name ? err.constructor.name : goog.debug.getFunctionName(err.constructor);\n        message = 'Unknown Error of type \"' + ctorName + '\"';\n        if (goog.debug.CHECK_FOR_THROWN_EVENT && ctorName == \"Event\") {\n          try {\n            message = message + ' with Event.type \"' + (err.type || \"\") + '\"';\n          } catch (e) {\n          }\n        }\n      } else {\n        message = \"Unknown Error of unknown type\";\n      }\n      if (typeof err.toString === \"function\" && Object.prototype.toString !== err.toString) {\n        message += \": \" + err.toString();\n      }\n    }\n    return {\"message\":message, \"name\":err.name || \"UnknownError\", \"lineNumber\":lineNumber, \"fileName\":fileName, \"stack\":stack || \"Not available\"};\n  }\n  err.stack = stack;\n  return {\"message\":err.message, \"name\":err.name, \"lineNumber\":err.lineNumber, \"fileName\":err.fileName, \"stack\":err.stack};\n};\ngoog.debug.serializeErrorStack_ = function(e, seen) {\n  if (!seen) {\n    seen = {};\n  }\n  seen[goog.debug.serializeErrorAsKey_(e)] = true;\n  var stack = e[\"stack\"] || \"\";\n  var cause = e.cause;\n  if (cause && !seen[goog.debug.serializeErrorAsKey_(cause)]) {\n    stack += \"\\nCaused by: \";\n    if (!cause.stack || cause.stack.indexOf(cause.toString()) != 0) {\n      stack += typeof cause === \"string\" ? cause : cause.message + \"\\n\";\n    }\n    stack += goog.debug.serializeErrorStack_(cause, seen);\n  }\n  return stack;\n};\ngoog.debug.serializeErrorAsKey_ = function(e) {\n  var keyPrefix = \"\";\n  if (typeof e.toString === \"function\") {\n    keyPrefix = \"\" + e;\n  }\n  return keyPrefix + e[\"stack\"];\n};\ngoog.debug.enhanceError = function(err, opt_message) {\n  var error;\n  if (!(err instanceof Error)) {\n    error = Error(err);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, goog.debug.enhanceError);\n    }\n  } else {\n    error = err;\n  }\n  if (!error.stack) {\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\n  }\n  if (opt_message) {\n    var x = 0;\n    while (error[\"message\" + x]) {\n      ++x;\n    }\n    error[\"message\" + x] = String(opt_message);\n  }\n  return error;\n};\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\n  var error = goog.debug.enhanceError(err);\n  if (opt_context) {\n    for (var key in opt_context) {\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\n    }\n  }\n  return error;\n};\ngoog.debug.getStacktraceSimple = function(opt_depth) {\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\n    if (stack) {\n      return stack;\n    }\n  }\n  var sb = [];\n  var fn = arguments.callee.caller;\n  var depth = 0;\n  while (fn && (!opt_depth || depth < opt_depth)) {\n    sb.push(goog.debug.getFunctionName(fn));\n    sb.push(\"()\\n\");\n    try {\n      fn = fn.caller;\n    } catch (e) {\n      sb.push(\"[exception trying to get caller]\\n\");\n      break;\n    }\n    depth++;\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\n      sb.push(\"[...long stack...]\");\n      break;\n    }\n  }\n  if (opt_depth && depth >= opt_depth) {\n    sb.push(\"[...reached max depth limit...]\");\n  } else {\n    sb.push(\"[end]\");\n  }\n  return sb.join(\"\");\n};\ngoog.debug.MAX_STACK_DEPTH = 50;\ngoog.debug.getNativeStackTrace_ = function(fn) {\n  var tempErr = new Error();\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(tempErr, fn);\n    return String(tempErr.stack);\n  } else {\n    try {\n      throw tempErr;\n    } catch (e) {\n      tempErr = e;\n    }\n    var stack = tempErr.stack;\n    if (stack) {\n      return String(stack);\n    }\n  }\n  return null;\n};\ngoog.debug.getStacktrace = function(fn) {\n  var stack;\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var contextFn = fn || goog.debug.getStacktrace;\n    stack = goog.debug.getNativeStackTrace_(contextFn);\n  }\n  if (!stack) {\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\n  }\n  return stack;\n};\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\n  var sb = [];\n  if (goog.array.contains(visited, fn)) {\n    sb.push(\"[...circular reference...]\");\n  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\n    sb.push(goog.debug.getFunctionName(fn) + \"(\");\n    var args = fn.arguments;\n    for (var i = 0; args && i < args.length; i++) {\n      if (i > 0) {\n        sb.push(\", \");\n      }\n      var argDesc;\n      var arg = args[i];\n      switch(typeof arg) {\n        case \"object\":\n          argDesc = arg ? \"object\" : \"null\";\n          break;\n        case \"string\":\n          argDesc = arg;\n          break;\n        case \"number\":\n          argDesc = String(arg);\n          break;\n        case \"boolean\":\n          argDesc = arg ? \"true\" : \"false\";\n          break;\n        case \"function\":\n          argDesc = goog.debug.getFunctionName(arg);\n          argDesc = argDesc ? argDesc : \"[fn]\";\n          break;\n        case \"undefined\":\n        default:\n          argDesc = typeof arg;\n          break;\n      }\n      if (argDesc.length > 40) {\n        argDesc = argDesc.substr(0, 40) + \"...\";\n      }\n      sb.push(argDesc);\n    }\n    visited.push(fn);\n    sb.push(\")\\n\");\n    try {\n      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\n    } catch (e) {\n      sb.push(\"[exception trying to get caller]\\n\");\n    }\n  } else if (fn) {\n    sb.push(\"[...long stack...]\");\n  } else {\n    sb.push(\"[end]\");\n  }\n  return sb.join(\"\");\n};\ngoog.debug.getFunctionName = function(fn) {\n  if (goog.debug.fnNameCache_[fn]) {\n    return goog.debug.fnNameCache_[fn];\n  }\n  var functionSource = String(fn);\n  if (!goog.debug.fnNameCache_[functionSource]) {\n    var matches = /function\\s+([^\\(]+)/m.exec(functionSource);\n    if (matches) {\n      var method = matches[1];\n      goog.debug.fnNameCache_[functionSource] = method;\n    } else {\n      goog.debug.fnNameCache_[functionSource] = \"[Anonymous]\";\n    }\n  }\n  return goog.debug.fnNameCache_[functionSource];\n};\ngoog.debug.makeWhitespaceVisible = function(string) {\n  return string.replace(/ /g, \"[_]\").replace(/\\f/g, \"[f]\").replace(/\\n/g, \"[n]\\n\").replace(/\\r/g, \"[r]\").replace(/\\t/g, \"[t]\");\n};\ngoog.debug.runtimeType = function(value) {\n  if (value instanceof Function) {\n    return value.displayName || value.name || \"unknown type name\";\n  } else if (value instanceof Object) {\n    return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);\n  } else {\n    return value === null ? \"null\" : typeof value;\n  }\n};\ngoog.debug.fnNameCache_ = {};\ngoog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {\n  return arg;\n};\ngoog.debug.freeze = function(arg) {\n  return {valueOf:function() {\n    return goog.debug.freezeInternal_(arg);\n  }}.valueOf();\n};\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Logging and debugging utilities.\n *\n * @see ../demos/debug.html\n */\n\ngoog.provide('goog.debug');\n\ngoog.require('goog.array');\ngoog.require('goog.debug.errorcontext');\n\n\n/** @define {boolean} Whether logging should be enabled. */\ngoog.debug.LOGGING_ENABLED =\n    goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);\n\n\n/** @define {boolean} Whether to force \"sloppy\" stack building. */\ngoog.debug.FORCE_SLOPPY_STACKS =\n    goog.define('goog.debug.FORCE_SLOPPY_STACKS', false);\n\n\n/**\n * @define {boolean} TODO(user): Remove this hack once bug is resolved.\n */\ngoog.debug.CHECK_FOR_THROWN_EVENT =\n    goog.define('goog.debug.CHECK_FOR_THROWN_EVENT', false);\n\n\n\n/**\n * Catches onerror events fired by windows and similar objects.\n * @param {function(Object)} logFunc The function to call with the error\n *    information.\n * @param {boolean=} opt_cancel Whether to stop the error from reaching the\n *    browser.\n * @param {Object=} opt_target Object that fires onerror events.\n * @suppress {strictMissingProperties} onerror is not defined as a property\n *    on Object.\n */\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\n  'use strict';\n  var target = opt_target || goog.global;\n  var oldErrorHandler = target.onerror;\n  var retVal = !!opt_cancel;\n\n  /**\n   * New onerror handler for this target. This onerror handler follows the spec\n   * according to\n   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors\n   * The spec was changed in August 2013 to support receiving column information\n   * and an error object for all scripts on the same origin or cross origin\n   * scripts with the proper headers. See\n   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n   *\n   * @param {string} message The error message. For cross-origin errors, this\n   *     will be scrubbed to just \"Script error.\". For new browsers that have\n   *     updated to follow the latest spec, errors that come from origins that\n   *     have proper cross origin headers will not be scrubbed.\n   * @param {string} url The URL of the script that caused the error. The URL\n   *     will be scrubbed to \"\" for cross origin scripts unless the script has\n   *     proper cross origin headers and the browser has updated to the latest\n   *     spec.\n   * @param {number} line The line number in the script that the error\n   *     occurred on.\n   * @param {number=} opt_col The optional column number that the error\n   *     occurred on. Only browsers that have updated to the latest spec will\n   *     include this.\n   * @param {Error=} opt_error The optional actual error object for this\n   *     error that should include the stack. Only browsers that have updated\n   *     to the latest spec will inlude this parameter.\n   * @return {boolean} Whether to prevent the error from reaching the browser.\n   */\n  target.onerror = function(message, url, line, opt_col, opt_error) {\n    'use strict';\n    if (oldErrorHandler) {\n      oldErrorHandler(message, url, line, opt_col, opt_error);\n    }\n    logFunc({\n      message: message,\n      fileName: url,\n      line: line,\n      lineNumber: line,\n      col: opt_col,\n      error: opt_error\n    });\n    return retVal;\n  };\n};\n\n\n/**\n * Creates a string representing an object and all its properties.\n * @param {Object|null|undefined} obj Object to expose.\n * @param {boolean=} opt_showFn Show the functions as well as the properties,\n *     default is false.\n * @return {string} The string representation of `obj`.\n */\ngoog.debug.expose = function(obj, opt_showFn) {\n  'use strict';\n  if (typeof obj == 'undefined') {\n    return 'undefined';\n  }\n  if (obj == null) {\n    return 'NULL';\n  }\n  var str = [];\n\n  for (var x in obj) {\n    if (!opt_showFn && typeof obj[x] === 'function') {\n      continue;\n    }\n    var s = x + ' = ';\n\n    try {\n      s += obj[x];\n    } catch (e) {\n      s += '*** ' + e + ' ***';\n    }\n    str.push(s);\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Creates a string representing a given primitive or object, and for an\n * object, all its properties and nested objects. NOTE: The output will include\n * Uids on all objects that were exposed. Any added Uids will be removed before\n * returning.\n * @param {*} obj Object to expose.\n * @param {boolean=} opt_showFn Also show properties that are functions (by\n *     default, functions are omitted).\n * @return {string} A string representation of `obj`.\n */\ngoog.debug.deepExpose = function(obj, opt_showFn) {\n  'use strict';\n  var str = [];\n\n  // Track any objects where deepExpose added a Uid, so they can be cleaned up\n  // before return. We do this globally, rather than only on ancestors so that\n  // if the same object appears in the output, you can see it.\n  var uidsToCleanup = [];\n  var ancestorUids = {};\n\n  var helper = function(obj, space) {\n    'use strict';\n    var nestspace = space + '  ';\n\n    var indentMultiline = function(str) {\n      'use strict';\n      return str.replace(/\\n/g, '\\n' + space);\n    };\n\n\n    try {\n      if (obj === undefined) {\n        str.push('undefined');\n      } else if (obj === null) {\n        str.push('NULL');\n      } else if (typeof obj === 'string') {\n        str.push('\"' + indentMultiline(obj) + '\"');\n      } else if (typeof obj === 'function') {\n        str.push(indentMultiline(String(obj)));\n      } else if (goog.isObject(obj)) {\n        // Add a Uid if needed. The struct calls implicitly adds them.\n        if (!goog.hasUid(obj)) {\n          uidsToCleanup.push(obj);\n        }\n        var uid = goog.getUid(obj);\n        if (ancestorUids[uid]) {\n          str.push('*** reference loop detected (id=' + uid + ') ***');\n        } else {\n          ancestorUids[uid] = true;\n          str.push('{');\n          for (var x in obj) {\n            if (!opt_showFn && typeof obj[x] === 'function') {\n              continue;\n            }\n            str.push('\\n');\n            str.push(nestspace);\n            str.push(x + ' = ');\n            helper(obj[x], nestspace);\n          }\n          str.push('\\n' + space + '}');\n          delete ancestorUids[uid];\n        }\n      } else {\n        str.push(obj);\n      }\n    } catch (e) {\n      str.push('*** ' + e + ' ***');\n    }\n  };\n\n  helper(obj, '');\n\n  // Cleanup any Uids that were added by the deepExpose.\n  for (var i = 0; i < uidsToCleanup.length; i++) {\n    goog.removeUid(uidsToCleanup[i]);\n  }\n\n  return str.join('');\n};\n\n\n/**\n * Recursively outputs a nested array as a string.\n * @param {Array<?>} arr The array.\n * @return {string} String representing nested array.\n */\ngoog.debug.exposeArray = function(arr) {\n  'use strict';\n  var str = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      str.push(goog.debug.exposeArray(arr[i]));\n    } else {\n      str.push(arr[i]);\n    }\n  }\n  return '[ ' + str.join(', ') + ' ]';\n};\n\n\n/**\n * Normalizes the error/exception object between browsers.\n * @param {*} err Raw error object.\n * @return {{\n *    message: (?|undefined),\n *    name: (?|undefined),\n *    lineNumber: (?|undefined),\n *    fileName: (?|undefined),\n *    stack: (?|undefined)\n * }} Representation of err as an Object. It will never return err.\n * @suppress {strictMissingProperties} properties not defined on err\n */\ngoog.debug.normalizeErrorObject = function(err) {\n  'use strict';\n  var href = goog.getObjectByName('window.location.href');\n  if (err == null) {\n    err = 'Unknown Error of type \"null/undefined\"';\n  }\n  if (typeof err === 'string') {\n    return {\n      'message': err,\n      'name': 'Unknown error',\n      'lineNumber': 'Not available',\n      'fileName': href,\n      'stack': 'Not available'\n    };\n  }\n\n  var lineNumber, fileName;\n  var threwError = false;\n\n  try {\n    lineNumber = err.lineNumber || err.line || 'Not available';\n  } catch (e) {\n    // Firefox 2 sometimes throws an error when accessing 'lineNumber':\n    // Message: Permission denied to get property UnnamedClass.lineNumber\n    lineNumber = 'Not available';\n    threwError = true;\n  }\n\n  try {\n    fileName = err.fileName || err.filename || err.sourceURL ||\n        // $googDebugFname may be set before a call to eval to set the filename\n        // that the eval is supposed to present.\n        goog.global['$googDebugFname'] || href;\n  } catch (e) {\n    // Firefox 2 may also throw an error when accessing 'filename'.\n    fileName = 'Not available';\n    threwError = true;\n  }\n\n  var stack = goog.debug.serializeErrorStack_(err);\n\n  // The IE Error object contains only the name and the message.\n  // The Safari Error object uses the line and sourceURL fields.\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||\n      !err.message || !err.name) {\n    var message = err.message;\n    if (message == null) {\n      if (err.constructor && err.constructor instanceof Function) {\n        var ctorName = err.constructor.name ?\n            err.constructor.name :\n            goog.debug.getFunctionName(err.constructor);\n        message = 'Unknown Error of type \"' + ctorName + '\"';\n        // TODO(user): Remove this hack once bug is resolved.\n        if (goog.debug.CHECK_FOR_THROWN_EVENT && ctorName == 'Event') {\n          try {\n            message = message + ' with Event.type \"' + (err.type || '') + '\"';\n          } catch (e) {\n            // Just give up on getting more information out of the error object.\n          }\n        }\n      } else {\n        message = 'Unknown Error of unknown type';\n      }\n\n      // Avoid TypeError since toString could be missing from the instance\n      // (e.g. if created Object.create(null)).\n      if (typeof err.toString === 'function' &&\n          Object.prototype.toString !== err.toString) {\n        message += ': ' + err.toString();\n      }\n    }\n    return {\n      'message': message,\n      'name': err.name || 'UnknownError',\n      'lineNumber': lineNumber,\n      'fileName': fileName,\n      'stack': stack || 'Not available'\n    };\n  }\n  // Standards error object\n  // Typed !Object. Should be a subtype of the return type, but it's not.\n  err.stack = stack;\n\n  // Return non-standard error to allow for consistent result (eg. enumerable).\n  return {\n    'message': err.message,\n    'name': err.name,\n    'lineNumber': err.lineNumber,\n    'fileName': err.fileName,\n    'stack': err.stack\n  };\n};\n\n\n/**\n * Serialize stack by including the cause chain of the exception if it exists.\n *\n *\n * @param {*} e an exception that may have a cause\n * @param {!Object=} seen set of cause that have already been serialized\n * @return {string}\n * @private\n * @suppress {missingProperties} properties not defined on cause and e\n */\ngoog.debug.serializeErrorStack_ = function(e, seen) {\n  'use strict';\n  if (!seen) {\n    seen = {};\n  }\n  seen[goog.debug.serializeErrorAsKey_(e)] = true;\n\n  var stack = e['stack'] || '';\n\n  // Add cause if exists.\n  var cause = e.cause;\n  if (cause && !seen[goog.debug.serializeErrorAsKey_(cause)]) {\n    stack += '\\nCaused by: ';\n    // Some browsers like Chrome add the error message as the first frame of the\n    // stack, In this case we don't need to add it. Note: we don't use\n    // String.startsWith method because it might have to be polyfilled.\n    if (!cause.stack || cause.stack.indexOf(cause.toString()) != 0) {\n      stack += (typeof cause === 'string') ? cause : cause.message + '\\n';\n    }\n    stack += goog.debug.serializeErrorStack_(cause, seen);\n  }\n\n  return stack;\n};\n\n/**\n * Serialize an error to a string key.\n * @param {*} e an exception\n * @return {string}\n * @private\n */\ngoog.debug.serializeErrorAsKey_ = function(e) {\n  'use strict';\n  var keyPrefix = '';\n\n  if (typeof e.toString === 'function') {\n    keyPrefix = '' + e;\n  }\n\n  return keyPrefix + e['stack'];\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * an extra message.\n * @param {*} err The original thrown error, object, or string.\n * @param {string=} opt_message  optional additional message to add to the\n *     error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceError = function(err, opt_message) {\n  'use strict';\n  var error;\n  if (!(err instanceof Error)) {\n    error = Error(err);\n    if (Error.captureStackTrace) {\n      // Trim this function off the call stack, if we can.\n      Error.captureStackTrace(error, goog.debug.enhanceError);\n    }\n  } else {\n    error = err;\n  }\n\n  if (!error.stack) {\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\n  }\n  if (opt_message) {\n    // find the first unoccupied 'messageX' property\n    var x = 0;\n    while (error['message' + x]) {\n      ++x;\n    }\n    error['message' + x] = String(opt_message);\n  }\n  return error;\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * context to the Error, which is reported by the closure error reporter.\n * @param {*} err The original thrown error, object, or string.\n * @param {!Object<string, string>=} opt_context Key-value context to add to the\n *     Error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\n  'use strict';\n  var error = goog.debug.enhanceError(err);\n  if (opt_context) {\n    for (var key in opt_context) {\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\n    }\n  }\n  return error;\n};\n\n\n/**\n * Gets the current stack trace. Simple and iterative - doesn't worry about\n * catching circular references or getting the args.\n * @param {number=} opt_depth Optional maximum depth to trace back to.\n * @return {string} A string with the function names of all functions in the\n *     stack, separated by \\n.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktraceSimple = function(opt_depth) {\n  'use strict';\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\n    if (stack) {\n      return stack;\n    }\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties.  Fall-through for legacy browser support.\n  }\n\n  var sb = [];\n  var fn = arguments.callee.caller;\n  var depth = 0;\n\n  while (fn && (!opt_depth || depth < opt_depth)) {\n    sb.push(goog.debug.getFunctionName(fn));\n    sb.push('()\\n');\n\n    try {\n      fn = fn.caller;\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n      break;\n    }\n    depth++;\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\n      sb.push('[...long stack...]');\n      break;\n    }\n  }\n  if (opt_depth && depth >= opt_depth) {\n    sb.push('[...reached max depth limit...]');\n  } else {\n    sb.push('[end]');\n  }\n\n  return sb.join('');\n};\n\n\n/**\n * Max length of stack to try and output\n * @type {number}\n */\ngoog.debug.MAX_STACK_DEPTH = 50;\n\n\n/**\n * @param {Function} fn The function to start getting the trace from.\n * @return {?string}\n * @private\n */\ngoog.debug.getNativeStackTrace_ = function(fn) {\n  'use strict';\n  var tempErr = new Error();\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(tempErr, fn);\n    return String(tempErr.stack);\n  } else {\n    // IE10, only adds stack traces when an exception is thrown.\n    try {\n      throw tempErr;\n    } catch (e) {\n      tempErr = e;\n    }\n    var stack = tempErr.stack;\n    if (stack) {\n      return String(stack);\n    }\n  }\n  return null;\n};\n\n\n/**\n * Gets the current stack trace, either starting from the caller or starting\n * from a specified function that's currently on the call stack.\n * @param {?Function=} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @return {string} Stack trace.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktrace = function(fn) {\n  'use strict';\n  var stack;\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    // Try to get the stack trace from the environment if it is available.\n    var contextFn = fn || goog.debug.getStacktrace;\n    stack = goog.debug.getNativeStackTrace_(contextFn);\n  }\n  if (!stack) {\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties. This function will throw in strict mode.\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\n  }\n  return stack;\n};\n\n\n/**\n * Private helper for getStacktrace().\n * @param {?Function} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @param {Array<!Function>} visited List of functions visited so far.\n * @return {string} Stack trace starting from function fn.\n * @suppress {es5Strict}\n * @private\n */\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\n  'use strict';\n  var sb = [];\n\n  // Circular reference, certain functions like bind seem to cause a recursive\n  // loop so we need to catch circular references\n  if (goog.array.contains(visited, fn)) {\n    sb.push('[...circular reference...]');\n\n    // Traverse the call stack until function not found or max depth is reached\n  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\n    sb.push(goog.debug.getFunctionName(fn) + '(');\n    var args = fn.arguments;\n    // Args may be null for some special functions such as host objects or eval.\n    for (var i = 0; args && i < args.length; i++) {\n      if (i > 0) {\n        sb.push(', ');\n      }\n      var argDesc;\n      var arg = args[i];\n      switch (typeof arg) {\n        case 'object':\n          argDesc = arg ? 'object' : 'null';\n          break;\n\n        case 'string':\n          argDesc = arg;\n          break;\n\n        case 'number':\n          argDesc = String(arg);\n          break;\n\n        case 'boolean':\n          argDesc = arg ? 'true' : 'false';\n          break;\n\n        case 'function':\n          argDesc = goog.debug.getFunctionName(arg);\n          argDesc = argDesc ? argDesc : '[fn]';\n          break;\n\n        case 'undefined':\n        default:\n          argDesc = typeof arg;\n          break;\n      }\n\n      if (argDesc.length > 40) {\n        argDesc = argDesc.substr(0, 40) + '...';\n      }\n      sb.push(argDesc);\n    }\n    visited.push(fn);\n    sb.push(')\\n');\n\n    try {\n      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n    }\n\n  } else if (fn) {\n    sb.push('[...long stack...]');\n  } else {\n    sb.push('[end]');\n  }\n  return sb.join('');\n};\n\n\n/**\n * Gets a function name\n * @param {Function} fn Function to get name of.\n * @return {string} Function's name.\n */\ngoog.debug.getFunctionName = function(fn) {\n  'use strict';\n  if (goog.debug.fnNameCache_[fn]) {\n    return goog.debug.fnNameCache_[fn];\n  }\n\n  // Heuristically determine function name based on code.\n  var functionSource = String(fn);\n  if (!goog.debug.fnNameCache_[functionSource]) {\n    var matches = /function\\s+([^\\(]+)/m.exec(functionSource);\n    if (matches) {\n      var method = matches[1];\n      goog.debug.fnNameCache_[functionSource] = method;\n    } else {\n      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';\n    }\n  }\n\n  return goog.debug.fnNameCache_[functionSource];\n};\n\n\n/**\n * Makes whitespace visible by replacing it with printable characters.\n * This is useful in finding diffrences between the expected and the actual\n * output strings of a testcase.\n * @param {string} string whose whitespace needs to be made visible.\n * @return {string} string whose whitespace is made visible.\n */\ngoog.debug.makeWhitespaceVisible = function(string) {\n  'use strict';\n  return string.replace(/ /g, '[_]')\n      .replace(/\\f/g, '[f]')\n      .replace(/\\n/g, '[n]\\n')\n      .replace(/\\r/g, '[r]')\n      .replace(/\\t/g, '[t]');\n};\n\n\n/**\n * Returns the type of a value. If a constructor is passed, and a suitable\n * string cannot be found, 'unknown type name' will be returned.\n *\n * <p>Forked rather than moved from {@link goog.asserts.getType_}\n * to avoid adding a dependency to goog.asserts.\n * @param {*} value A constructor, object, or primitive.\n * @return {string} The best display name for the value, or 'unknown type name'.\n */\ngoog.debug.runtimeType = function(value) {\n  'use strict';\n  if (value instanceof Function) {\n    return value.displayName || value.name || 'unknown type name';\n  } else if (value instanceof Object) {\n    return /** @type {string} */ (value.constructor.displayName) ||\n        value.constructor.name || Object.prototype.toString.call(value);\n  } else {\n    return value === null ? 'null' : typeof value;\n  }\n};\n\n\n/**\n * Hash map for storing function names that have already been looked up.\n * @type {Object}\n * @private\n */\ngoog.debug.fnNameCache_ = {};\n\n\n/**\n * Private internal function to support goog.debug.freeze.\n * @param {T} arg\n * @return {T}\n * @template T\n * @private\n */\ngoog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {\n  'use strict';\n  return arg;\n};\n\n\n/**\n * Freezes the given object, but only in debug mode (and in browsers that\n * support it).  Note that this is a shallow freeze, so for deeply nested\n * objects it must be called at every level to ensure deep immutability.\n * @param {T} arg\n * @return {T}\n * @template T\n */\ngoog.debug.freeze = function(arg) {\n  'use strict';\n  // NOTE: this compiles to nothing, but hides the possible side effect of\n  // freezeInternal_ from the compiler so that the entire call can be\n  // removed if the result is not used.\n  return {\n    valueOf: function() {\n      'use strict';\n      return goog.debug.freezeInternal_(arg);\n    }\n  }.valueOf();\n};\n","~:compiled-at",1668862146616,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.debug.debug.js\",\n\"lineCount\":1,\n\"mappings\":\";\",\n\"sources\":[],\n\"names\":[]\n}\n"]